<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Writing Intest Recipes</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/ConsoleText-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Intest.png" height=72">
</a></h1>
<ul><li><a href="index.html"><span class="selectedlink">intest</span></a></li>
</ul><h2>Repository</h2><ul>
<li><a href="https://github.com/ganelson/intest"><img src="../docs-assets/github.png" height=18> github</a></li>
</ul><h2>Related Projects</h2><ul>
<li><a href="../../../inweb/docs/index.html">inweb</a></li>
<li><a href="../../../inform/docs/index.html">inform</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Writing Intest Recipes' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="index.html">intest</a></li><li><a href="index.html#M">Manual</a></li><li><b>Writing Intest Recipes</b></li></ul></div>
<p class="purpose">A guide to writing in Delia, Intest's recipe language.</p>

<ul class="toc"><li><a href="M-wir.html#SP1">&#167;1. Writing Delia</a></li><li><a href="M-wir.html#SP2">&#167;2. Syntax and tokens</a></li><li><a href="M-wir.html#SP3">&#167;3. Variables</a></li><li><a href="M-wir.html#SP9">&#167;9. Expansion</a></li><li><a href="M-wir.html#SP16">&#167;16. Control flow</a></li><li><a href="M-wir.html#SP20">&#167;20. Steps</a></li><li><a href="M-wir.html#SP22">&#167;22. Matches</a></li><li><a href="M-wir.html#SP25">&#167;25. Files and directories</a></li><li><a href="M-wir.html#SP27">&#167;27. Conditionals</a></li><li><a href="M-wir.html#SP36">&#167;36. Cautionary tale about encodings</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. Writing Delia. </b>Recipe definitions are written in a very simple mini-language called Delia,
for reasons which English users of Intest will appreciate. Had Intest been
written by an American, it would have been called Julia.
</p>

<p class="commentary">This example recipe shows the basic syntax. In this recipe, which creates three
"variables" <span class="extract"><span class="extract-syntax">$A</span></span>, <span class="extract"><span class="extract-syntax">$I</span></span> and <span class="extract"><span class="extract-syntax">$SOURCE</span></span>, a command-line program called <span class="extract"><span class="extract-syntax">launcher</span></span>
is to be called using <span class="extract"><span class="extract-syntax">$SOURCE</span></span> as the filename of its input. Its output is
then redirected into the file <span class="extract"><span class="extract-syntax">$A</span></span>, which is compared against <span class="extract"><span class="extract-syntax">$I</span></span> to see
if the right output was printed.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    set</span><span class="plain-syntax">: </span><span class="function-syntax">$SOURCE</span><span class="plain-syntax"> = </span><span class="function-syntax">$PATH</span><span class="plain-syntax">/</span><span class="function-syntax">$CASE</span><span class="plain-syntax">.txt</span>
<span class="reserved-syntax">    set</span><span class="plain-syntax">: </span><span class="function-syntax">$A</span><span class="plain-syntax"> = </span><span class="function-syntax">$PATH</span><span class="plain-syntax">/</span><span class="function-syntax">$CASE</span><span class="plain-syntax">--A.txt</span>
<span class="reserved-syntax">    set</span><span class="plain-syntax">: </span><span class="function-syntax">$I</span><span class="plain-syntax"> = </span><span class="function-syntax">$PATH</span><span class="plain-syntax">/</span><span class="function-syntax">$CASE</span><span class="plain-syntax">--I.txt</span>

<span class="reserved-syntax">    step</span><span class="plain-syntax">: launcher </span><span class="function-syntax">$SOURCE</span><span class="plain-syntax"> &gt;</span><span class="function-syntax">$A</span><span class="plain-syntax"> 2&gt;&amp;1</span>
<span class="reserved-syntax">    or</span><span class="plain-syntax">: 'launcher produced error messages' </span><span class="function-syntax">$A</span>

<span class="reserved-syntax">    exists</span><span class="plain-syntax">: </span><span class="function-syntax">$I</span>
<span class="reserved-syntax">    or</span><span class="plain-syntax">: 'launcher produced no errors, but no blessed output existed'</span>

<span class="reserved-syntax">    match text</span><span class="plain-syntax">: </span><span class="function-syntax">$A</span><span class="plain-syntax"> </span><span class="function-syntax">$I</span>
<span class="reserved-syntax">    or</span><span class="plain-syntax">: 'produced incorrect output'</span>

<span class="reserved-syntax">    pass</span><span class="plain-syntax">: 'passed'</span>
</pre>
<p class="commentary">In this example the test has four possible outcomes at which it might
halt: at the three <span class="extract"><span class="extract-syntax">or:...</span></span> lines, which halt a test because the previous
instruction failed in some way; or, if things go better, on the last line
where the <span class="extract"><span class="extract-syntax">pass:</span></span> instruction says that the test has completed as it should.
</p>

<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2. Syntax and tokens. </b>Blanks lines and lines beginning with exclamation marks <span class="extract"><span class="extract-syntax">!</span></span> are ignored.
All other lines must have the form
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    command</span><span class="plain-syntax">: token1 ... tokenN</span>
</pre>
<p class="commentary">where different commands need different numbers of "tokens".
</p>

<p class="commentary">The command and its tokens must occupy a single line and no comment is
allowed at the end of it. Quotation marks can be used to make multiple words
a single token; thus:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    exists</span><span class="plain-syntax">: 'My Tests/output.txt'</span>
</pre>
<p class="commentary">is a command plus a single token, not two. A backslash can be used to escape
the quotation mark when inside quotes.
</p>

<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3. Variables. </b>Delia has just one data structure: a set of named variables. The language has
no concept of "types": all data is text. A variable can hold any amount of
text, including none. Note that there is a difference between a variable
existing but holding the empty text as its value, and not existing at all.
</p>

<p class="commentary">In practice, this text is usually used to hold filenames, pathnames, or
fragments of command-line commands not yet issued, but it can in principle
be used for almost anything.
</p>

<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4.  </b>Variables can be either "global", written <span class="extract"><span class="extract-syntax">$$NAME</span></span>, or "local", written
<span class="extract"><span class="extract-syntax">$NAME</span></span>. A Delia recipe can create and modify local variables freely, but
can neither create nor modify globals, which are handed down to it from above.
They are therefore constant throughout the life of a test which is running, and
they have the same value for all tests being conducted in the same run of
Intest. The following globals are automatically defined:
</p>

<ul class="items"><li>(1) <span class="extract"><span class="extract-syntax">$$platform</span></span>, as mentioned above, which is a string such as <span class="extract"><span class="extract-syntax">osx</span></span> or <span class="extract"><span class="extract-syntax">windows</span></span>.
Avoid using this where possible. All other global variables are created
by the <span class="extract"><span class="extract-syntax">-set</span></span> command at the top of the recipe file: see above.
</li><li>(2) <span class="extract"><span class="extract-syntax">$$project</span></span> is the path to the project being tested.
</li><li>(3) <span class="extract"><span class="extract-syntax">$$internal</span></span> is the path to the Inform internals directory, assumed to be
<span class="extract"><span class="extract-syntax">inform7/Internal</span></span> unless the <span class="extract"><span class="extract-syntax">-internal</span></span> switch has said otherwise. This will
only be useful for testing Inform-related programs, of course, and not always then.
</li><li>(4) <span class="extract"><span class="extract-syntax">$$workspace</span></span> is the path to a directory where Intest can write temporary
files as it pleases. Do not use this for throwaway files in the course of a
test unless you are quite sure multiple tests running at once will not interfere
with each other: if you are not sure, use <span class="extract"><span class="extract-syntax">$WORK</span></span> instead (see below).
</li><li>(5) <span class="extract"><span class="extract-syntax">$$nest</span></span> is used only internally, and on automatic tests of extensions or
kits for Inform: it then holds the path to the directory or "nest" of resources
from which the extension or kit seems to be drawn.
</li></ul>
<p class="commentary">Other global variables may have been created using <span class="extract"><span class="extract-syntax">-set</span></span> in the intest
file, for which see <a href="M-tuoc.html" class="internal">The Universe of Cases</a>, or at the command line.
For example,
</p>

<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">../intest/Tangled/intest</span><span class="ConsoleText-plain-syntax"> inform7</span><span class="ConsoleText-identifier-syntax"> -set</span><span class="ConsoleText-plain-syntax"> WORD=plugh all</span>
</pre>
<p class="commentary">runs the tests for <span class="extract"><span class="ConsoleText-extract-syntax">inform7</span></span> with the global variable <span class="extract"><span class="ConsoleText-extract-syntax">$$WORD</span></span> set to <span class="extract"><span class="ConsoleText-extract-syntax">plugh</span></span>.
</p>

<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5.  </b>For the most part, a Delia recipe can create its own local variables quite
freely, but it doesn't begin with a completely blank slate. As it starts:
</p>

<ul class="items"><li>(1) <span class="extract"><span class="ConsoleText-extract-syntax">$CASE</span></span> is the name (not the title, if that differs) of the test case.
</li><li>(2) <span class="extract"><span class="ConsoleText-extract-syntax">$TITLE</span></span> is the title (not the name, if that differs) of the test case.
</li><li>(3) <span class="extract"><span class="ConsoleText-extract-syntax">$PATH</span></span> is the pathname to the directory which the test case is in.
</li><li>(4) <span class="extract"><span class="ConsoleText-extract-syntax">$TYPE</span></span> is the type of test case this is: <span class="extract"><span class="ConsoleText-extract-syntax">case</span></span>, <span class="extract"><span class="ConsoleText-extract-syntax">problem</span></span>, <span class="extract"><span class="ConsoleText-extract-syntax">example</span></span>,
<span class="extract"><span class="ConsoleText-extract-syntax">extension</span></span>.
</li><li>(5) <span class="extract"><span class="ConsoleText-extract-syntax">$WORK</span></span> is the pathname of a directory set aside by Intest for any intermediate
files we might need to produce during the test process &mdash; these must all be
temporary files we can happily lose when the test is completed. The real
usefulness of this comes when Intest is running a batch of tests across
multiple threads, because those threads each need their own independent work
area to avoid stepping on each other's feet. Provided the recipe uses <span class="extract"><span class="ConsoleText-extract-syntax">$WORK</span></span>,
it never needs to think about this complication.
</li><li>(6) If the Intest file specifies "stipulations" on the test case, those set
local variables for it: see <a href="M-tuoc.html" class="internal">The Universe of Cases</a>. In this example,
the recipe <span class="extract"><span class="ConsoleText-extract-syntax">[Reactor]</span></span> starts with the given settings of <span class="extract"><span class="ConsoleText-extract-syntax">$TEMP</span></span> and <span class="extract"><span class="ConsoleText-extract-syntax">$STATUS</span></span>.
</li></ul>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    -cases [Reactor</span><span class="plain-syntax">:TEMP=Hot:STATUS=Safe] 'fusionreactor/Tests/HotCases'</span>
<span class="reserved-syntax">    -cases [Reactor</span><span class="plain-syntax">:TEMP=Cold:STATUS=Safe] 'fusionreactor/Tests/ColdCases'</span>
<span class="reserved-syntax">    -cases [Reactor</span><span class="plain-syntax">:TEMP=Hot:STATUS=Unsafe] 'fusionreactor/Tests/UnsafeCases'</span>
</pre>
<ul class="items"><li>(7) If the test case itself contains annotations, those are also used to
create local variables which the test starts with. In the following example,
any test of <span class="extract"><span class="extract-syntax">Nettles</span></span> would begin with the recipe having appropriate values
of <span class="extract"><span class="extract-syntax">$LANGUAGE</span></span>, <span class="extract"><span class="extract-syntax">$FOR</span></span> and <span class="extract"><span class="extract-syntax">$INTOPTIONS</span></span>.
</li></ul>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    Test: Nettles</span>
<span class="plain-syntax">    Language: Basic</span>
<span class="plain-syntax">    For: Glulx</span>
<span class="plain-syntax">    IntOptions: -u -q -dataresourcetext '3:$PATH/Nettles--X.txt'</span>
</pre>
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6.  </b>The special variable <span class="extract"><span class="extract-syntax">$SCRIPT</span></span> is created by the <span class="extract"><span class="extract-syntax">extract:</span></span> instruction
(see below), and is only useful for testing Inform. It is created if one
of two things happens:
</p>

<ul class="items"><li>(a) A text file exists in the same directory as the test case, and with the
<span class="extract"><span class="extract-syntax">--S</span></span> filename suffix. For example, if the test is in <span class="extract"><span class="extract-syntax">zap/Tests/Cases/DeathRay.txt</span></span>,
then Intest will look for the file <span class="extract"><span class="extract-syntax">zap/Tests/Cases/DeathRay--S.txt</span></span>. If that
file exists, <span class="extract"><span class="extract-syntax">$SCRIPT</span></span> will be set to its filename.
</li><li>(b) The test case contains a sentence of source text in the form
"Test me with "Command 1 / Command 2 / ..."." If it does, Intest will
use a generic script which types TEST ME, then QUIT, then Y (to confirm
quitting), and will set <span class="extract"><span class="extract-syntax">$SCRIPT</span></span> to that filename.
</li></ul>
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7.  </b>The special variable <span class="extract"><span class="extract-syntax">$HASHCODE</span></span> is created by the <span class="extract"><span class="extract-syntax">hash:</span></span> instruction:
see below.
</p>

<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8.  </b>When tinkering with recipes, it's sometimes very helpful to be able to
see what's happening to all of these variables. Running Intest in its
<span class="extract"><span class="extract-syntax">-verbose</span></span> mode will do that. For example, if we run Intest on its
example project, we can sit back and watch what it's doing:
</p>

<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">intest/Tangled/intest</span><span class="ConsoleText-plain-syntax"> intest/Examples/dc</span><span class="ConsoleText-identifier-syntax"> -verbose</span><span class="ConsoleText-plain-syntax"> minus</span>
<span class="ConsoleText-plain-syntax">...</span>
<span class="ConsoleText-plain-syntax">Global variables:</span>
<span class="ConsoleText-plain-syntax">      $$platform = macos</span>
<span class="ConsoleText-plain-syntax">      $$project = intest/Examples/dc/Tests</span>
<span class="ConsoleText-plain-syntax">      $$internal = inform7/Internal</span>
<span class="ConsoleText-plain-syntax">      $$workspace = /Users/gnelson/Natural Inform/intest/Workspace</span>
<span class="ConsoleText-plain-syntax">Local variables at start:</span>
<span class="ConsoleText-plain-syntax">      $CASE &lt;--- minus</span>
<span class="ConsoleText-plain-syntax">      $TITLE &lt;---</span>
<span class="ConsoleText-plain-syntax">      $PATH &lt;--- intest/Examples/dc/Tests/Cases</span>
<span class="ConsoleText-plain-syntax">      $WORK &lt;--- /Users/gnelson/Natural Inform/intest/Workspace/T0</span>
<span class="ConsoleText-plain-syntax">      $TYPE &lt;--- case</span>
<span class="ConsoleText-plain-syntax">Recipe execution:</span>
<span class="ConsoleText-plain-syntax">0001:   mkdir: $PATH/_actual</span>
<span class="ConsoleText-plain-syntax">shell: mkdir -p 'intest/Examples/dc/Tests/Cases/_actual'</span>
<span class="ConsoleText-plain-syntax">0002:   mkdir: $PATH/_ideal</span>
<span class="ConsoleText-plain-syntax">shell: mkdir -p 'intest/Examples/dc/Tests/Cases/_ideal'</span>
<span class="ConsoleText-plain-syntax">0003:   set: $A = $PATH/_actual/$CASE.txt</span>
<span class="ConsoleText-plain-syntax">      $A &lt;--- intest/Examples/dc/Tests/Cases/_actual/minus.txt</span>
<span class="ConsoleText-plain-syntax">0004:   set: $I = $PATH/_ideal/$CASE.txt</span>
<span class="ConsoleText-plain-syntax">      $I &lt;--- intest/Examples/dc/Tests/Cases/_ideal/minus.txt</span>
<span class="ConsoleText-plain-syntax">0005:   step: dc $[$PATH/$CASE.txt$] &gt;$A 2&gt;&amp;1</span>
<span class="ConsoleText-plain-syntax">shell: 'dc'  '-e'  '10 3 - p' &gt;'intest/Examples/dc/Tests/Cases/_actual/minus.txt'  2&gt;&amp;1</span>
<span class="ConsoleText-plain-syntax">0006:   or: 'failed dc' $A</span>
<span class="ConsoleText-plain-syntax">0007:   show: $A</span>
<span class="ConsoleText-plain-syntax">0008:   match text: $A $I</span>
<span class="ConsoleText-plain-syntax">0009:   or: 'produced the wrong output'</span>
<span class="ConsoleText-plain-syntax">0010:   pass: 'passed'</span>
</pre>
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9. Expansion. </b>Variables are only useful for their values, and their values are used by
means of "expansion".
</p>

<p class="commentary">When Delia reads the token <span class="extract"><span class="ConsoleText-extract-syntax">$PATH/$CASE.txt</span></span>, for example, it substitutes in
the values of <span class="extract"><span class="ConsoleText-extract-syntax">$PATH</span></span> and <span class="extract"><span class="ConsoleText-extract-syntax">$CASE</span></span>. If <span class="extract"><span class="ConsoleText-extract-syntax">$PATH</span></span> is <span class="extract"><span class="ConsoleText-extract-syntax">zap/Tests</span></span> and <span class="extract"><span class="ConsoleText-extract-syntax">$CASE</span></span> is
<span class="extract"><span class="ConsoleText-extract-syntax">planets</span></span>, the result would be <span class="extract"><span class="ConsoleText-extract-syntax">zap/Tests/planets.txt</span></span>. This process is called
"expansion", and Delia applies it to almost every token.
</p>

<p class="commentary">Expansion fails with an error if the local variable named does not in fact
exist. Thus Intest will refuse to expand <span class="extract"><span class="ConsoleText-extract-syntax">My$BARGAIN</span></span>, rather than expand it
to just <span class="extract"><span class="ConsoleText-extract-syntax">My</span></span> or leave it as it stands, if the variable <span class="extract"><span class="ConsoleText-extract-syntax">$BARGAIN</span></span> does not
exist. (This is even true if the variable <span class="extract"><span class="ConsoleText-extract-syntax">$BARGAI</span></span> should exist.)
</p>

<p class="commentary">The instruction <span class="extract"><span class="ConsoleText-extract-syntax">set:</span></span> either creates a new local variable, or changes the
value of an existing one:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    set</span><span class="plain-syntax">: </span><span class="function-syntax">$NAME</span><span class="plain-syntax"> = VALUE</span>
</pre>
<p class="commentary">Note that the <span class="extract"><span class="extract-syntax">VALUE</span></span> token here is expanded, but the <span class="extract"><span class="extract-syntax">$NAME</span></span> token is not,
for obvious reasons. This is one of the exceptions hinted at above.
</p>

<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10.  </b>A wrinkle here is that if the setting value has multiple tokens:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    set</span><span class="plain-syntax">: </span><span class="function-syntax">$NAME</span><span class="plain-syntax"> = VALUE1 VALUE2 ...</span>
</pre>
<p class="commentary">then they are each "quote-expanded", rather than being simply "expanded".
This basically means that the value is meant to be used in place of a string
of tokens, rather than as a fragment or the whole of a single token.
For example:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    set</span><span class="plain-syntax">: </span><span class="function-syntax">$OPTIONS</span><span class="plain-syntax"> = -no-warnings -p=10 -to </span><span class="function-syntax">$FILE</span><span class="plain-syntax">.txt</span>
</pre>
<p class="commentary">sets the value to be
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    '-no-warnings' '-p=10' '-verbose' '-to' 'My File.txt'</span>
</pre>
<p class="commentary">This precaution is in case, as happened in this example, expansion of one of
the tokens, <span class="extract"><span class="extract-syntax">$FILE.txt</span></span>, brought in new white space &mdash; here, the space between
"My" and "File".
</p>

<p class="commentary firstcommentary"><a id="SP11" class="paragraph-anchor"></a><b>&#167;11.  </b>The instruction <span class="extract"><span class="extract-syntax">default:</span></span> is entirely the same as <span class="extract"><span class="extract-syntax">set:</span></span>, except that it
takes effect only if the variable does not yet exist. Thus:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    default</span><span class="plain-syntax">: </span><span class="function-syntax">$FUEL</span><span class="plain-syntax"> = Kerosene</span>
</pre>
<p class="commentary">is exactly equivalent to
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    ifndef</span><span class="plain-syntax">: </span><span class="function-syntax">$FUEL</span>
<span class="reserved-syntax">        set</span><span class="plain-syntax">: </span><span class="function-syntax">$FUEL</span><span class="plain-syntax"> = Kerosene</span>
<span class="reserved-syntax">    endif</span>
</pre>
<p class="commentary">but is less laborious.
</p>

<p class="commentary firstcommentary"><a id="SP12" class="paragraph-anchor"></a><b>&#167;12.  </b>Quote-expansion is not always what we want. For example, suppose we further
defined:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    set</span><span class="plain-syntax">: </span><span class="function-syntax">$MOREOPTIONS</span><span class="plain-syntax"> = </span><span class="function-syntax">$OPTIONS</span><span class="plain-syntax"> -lang=en-uk</span>
</pre>
<p class="commentary">We would then get the value:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    '\'-no-warnings\' \'-p=10\' \'-verbose\' \'-to\' \'My File.txt\'' '-lang=en-uk'</span>
</pre>
<p class="commentary">which of course is wrong. We avoid this using a backtick to suppress quote
expansion of the first token:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    set</span><span class="plain-syntax">: </span><span class="function-syntax">$MOREOPTIONS</span><span class="plain-syntax"> = `</span><span class="function-syntax">$OPTIONS</span><span class="plain-syntax"> -lang=en-uk</span>
</pre>
<p class="commentary">which gets it right:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    '-no-warnings' '-p=10' '-verbose' '-to' 'My File.txt' '-lang=en-uk'</span>
</pre>
<p class="commentary">Note that quote expansion respects the Unix shell redirection markers like
<span class="extract"><span class="extract-syntax">&gt;file</span></span> or <span class="extract"><span class="extract-syntax">2&gt;&amp;1</span></span>, quoting just the file parts.
</p>

<p class="commentary firstcommentary"><a id="SP13" class="paragraph-anchor"></a><b>&#167;13.  </b>Quote-expansion also supports one more feature: the token <span class="extract"><span class="extract-syntax">$[filename$]</span></span>
expands to the (tokenised and further expanded) contents of the file named.
Thus for example if the file <span class="extract"><span class="extract-syntax">Frog.txt</span></span> contains the words "never turn your
back on a frog", then
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    $[Frog.txt$]</span>
</pre>
<p class="commentary">will quote-expand to:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    'never' 'turn' 'your' 'back' 'on' 'a' 'frog'</span>
</pre>
<p class="commentary">By default, the contents of the file will themselves be expanded, if they
contain names with <span class="extract"><span class="extract-syntax">$</span></span> or <span class="extract"><span class="extract-syntax">$$</span></span> prefixes. To avoid that (and thus treat dollar
signs in the file as being literal), use yet another backtick:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    $[`Toad.txt$]</span>
</pre>
<p class="commentary firstcommentary"><a id="SP14" class="paragraph-anchor"></a><b>&#167;14.  </b>Finally, the syntax
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    ${Salamander.mp3$}</span>
</pre>
<p class="commentary">will quote-expand to an MD5 hash of the file named. This should exactly match
what the <span class="extract"><span class="extract-syntax">md5</span></span> tool supplied on most Unixes would give; for example, an empty
file would quote-expand to <span class="extract"><span class="extract-syntax">d41d8cd98f00b204e9800998ecf8427e</span></span>.
</p>

<p class="commentary">Two special modified versions of this are available for taking hashes of
story files for the Z-machine or Glulx, which are useful for tests of Inform.
Thus <span class="extract"><span class="extract-syntax">${zmachine:Salamander.z3$}</span></span> or <span class="extract"><span class="extract-syntax">${glulx:Salamander.ulx$}</span></span> take hashes
in a way which masks certain bytes of their headers as zeros; here we match
the conventions used by Andrew Plotkin's test program for Inform 6. The idea
is that we want to ignore things like the time-stamp and compiler version,
which will change daily.
</p>

<p class="commentary firstcommentary"><a id="SP15" class="paragraph-anchor"></a><b>&#167;15.  </b>Note that the filename is itself expanded before use, so that it can be
defined using variables. This can be very useful when we want to test a
program which takes its input mainly in the form of command-line arguments,
rather than from a file. See the example supplied with Intest for testing
"dc", the very old-school reverse Polish notation calculator supplied with
most Unix systems (including MacOS). In that example, a test case such as
<span class="extract"><span class="extract-syntax">dc/Tests/Cases/plus.txt</span></span> contains what to put on the command line when
running dc:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    -e '1 1 + p'</span>
</pre>
<p class="commentary">The important step in the recipe for using this then reads:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    step</span><span class="plain-syntax">: dc $[</span><span class="function-syntax">$PATH</span><span class="plain-syntax">/</span><span class="function-syntax">$CASE</span><span class="plain-syntax">.txt$]</span>
</pre>
<p class="commentary">and this causes Intest to run the command:
</p>

<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">dc</span><span class="ConsoleText-identifier-syntax"> -e</span><span class="ConsoleText-plain-syntax"> '1 1 + p'</span>
</pre>
<p class="commentary">which produces the concise output "2".
</p>

<p class="commentary firstcommentary"><a id="SP16" class="paragraph-anchor"></a><b>&#167;16. Control flow. </b>As we shall see, there are conditionals in the Delia language, but no loops
and no subroutines, macros, function or procedure calls. Delia is intentionally
not Turing-complete: it tries to balance flexibility with simplicity.
</p>

<p class="commentary">A test therefore flows from top to bottom of the recipe, perhaps skipping some
stages because of conditionals. But it doesn't always get to the bottom, because
a multi-stage test can end early for several reasons.
</p>

<p class="commentary">One way a test can halt is if it runs into one of the "stopping commands":
</p>

<p class="commentary"><span class="extract"><span class="ConsoleText-extract-syntax">pass: 'NOTE'</span></span>. Stops the test and marks it a success. The text <span class="extract"><span class="ConsoleText-extract-syntax">'NOTE'</span></span>
is optional, and is a summary used when Intest prints its results.
</p>

<p class="commentary"><span class="extract"><span class="ConsoleText-extract-syntax">fail: 'NOTE' FILE</span></span>. Stops the test and marks it a failure. The text <span class="extract"><span class="ConsoleText-extract-syntax">'NOTE'</span></span>
is optional, and is a summary used when Intest prints its results. The <span class="extract"><span class="ConsoleText-extract-syntax">FILE</span></span>,
which is also optional, is then printed out when Intest describes what went
wrong.
</p>

<p class="commentary">But tests can also halt because one of its steps or matches fails. For example,
perhaps a test needs to run a C compiler as a step, and this unexpectedly
produces error messages rather than compiling. When that happens, a test
will usually stop immediately and will be marked as a failure. However:
</p>

<p class="commentary"><span class="extract"><span class="ConsoleText-extract-syntax">or: 'NOTE' FILE</span></span>. If the step or match performed immediately before this line
failed, the failure message <span class="extract"><span class="ConsoleText-extract-syntax">'NOTE'</span></span> is used. The <span class="extract"><span class="ConsoleText-extract-syntax">FILE</span></span>, which is optional,
is then printed out when Intest describes what went wrong. For example:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    step</span><span class="plain-syntax">: dc -e </span><span class="function-syntax">$EXPRESSION</span>
<span class="reserved-syntax">    or</span><span class="plain-syntax">: 'dc produced an error'</span>
</pre>
<p class="commentary">More generally, the conditional <span class="extract"><span class="extract-syntax">iffail:</span></span> can be used, which causes the rest
to continue despite the failure of a step. In fact, that last example is
equivalent to:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    step</span><span class="plain-syntax">: dc -e </span><span class="function-syntax">$EXPRESSION</span>
<span class="reserved-syntax">    iffail</span><span class="plain-syntax">:</span>
<span class="reserved-syntax">        fail</span><span class="plain-syntax">: 'dc produced an error'</span>
<span class="reserved-syntax">    endif</span>
</pre>
<p class="commentary"><span class="extract"><span class="extract-syntax">iffail:</span></span> can thus be used to send tests down differing paths if steps fail.
</p>

<p class="commentary firstcommentary"><a id="SP17" class="paragraph-anchor"></a><b>&#167;17.  </b>Control also stops, with a pass for the test, if it runs into a <span class="extract"><span class="extract-syntax">show: ...</span></span>
command of the right sort when the tester is looking for that. For example,
suppose the command being used is:
</p>

<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">intest/Tangled/intest</span><span class="ConsoleText-plain-syntax"> inform7</span><span class="ConsoleText-identifier-syntax"> -show-transcript</span><span class="ConsoleText-plain-syntax"> Pine2</span>
</pre>
<p class="commentary">The tester then runs the test case <span class="extract"><span class="ConsoleText-extract-syntax">Pine2</span></span> in hopes of running into an
instruction like this:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    show</span><span class="plain-syntax">: transcript </span><span class="function-syntax">$TF</span>
</pre>
<p class="commentary">If it finds such an instruction, it prints out the file which <span class="extract"><span class="extract-syntax">$TF</span></span> (i.e.,
the second token, whatever it is) and ends the test then and there.
</p>

<p class="commentary">If the tester is not looking to show a transcript, it will pass over
<span class="extract"><span class="extract-syntax">show: transcript ...</span></span> doing nothing.
</p>

<p class="commentary firstcommentary"><a id="SP18" class="paragraph-anchor"></a><b>&#167;18.  </b>If a target is considered especially important to see, it can be given
the empty target name. The command for that is then <span class="extract"><span class="extract-syntax">show: $X</span></span>, with just
one token, and the tester looks for this in response to just <span class="extract"><span class="extract-syntax">-show</span></span>
on the command line, rather than a more general <span class="extract"><span class="extract-syntax">-show-TARGET</span></span>.
</p>

<p class="commentary firstcommentary"><a id="SP19" class="paragraph-anchor"></a><b>&#167;19.  </b>If the file does not exist for some reason, the test continues, but the
step is considered a fail. This possibility can be picked up by placing
an <span class="extract"><span class="extract-syntax">or:</span></span> immediately following:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    show</span><span class="plain-syntax">: transcript </span><span class="function-syntax">$TF</span>
<span class="reserved-syntax">    or</span><span class="plain-syntax">: 'heaven knows why, but the transcript file does not exist'</span>
</pre>
<p class="commentary firstcommentary"><a id="SP20" class="paragraph-anchor"></a><b>&#167;20. Steps. </b>A "step" is a shell command issued to the host system: it actually does
something as part of the test, in other words, rather than simply preparing
to do things or looking at the result.
</p>

<p class="commentary">There are two sorts of step:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">step: COMMAND</span></span>. Runs the shell command <span class="extract"><span class="extract-syntax">COMMAND</span></span>. The step passes if the
command returns the exit code 0, which for Unix utilities conventionally
means that no errors occurred. It fails on all non-zero exit codes.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">fail step: COMMAND</span></span>. The same as <span class="extract"><span class="extract-syntax">step:</span></span>, but this time expecting a non-zero exit
code, and failing on zero.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">debugger: COMMAND</span></span>. The same as <span class="extract"><span class="extract-syntax">step:</span></span>, but runs the command in only when
the test is being run by the <span class="extract"><span class="extract-syntax">-debug</span></span> action. The idea is to do something
like this:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    debugger</span><span class="plain-syntax">: lldb -f launcher -- </span><span class="function-syntax">$SOURCE</span>
<span class="reserved-syntax">    step</span><span class="plain-syntax">: launcher </span><span class="function-syntax">$SOURCE</span><span class="plain-syntax"> &gt;</span><span class="function-syntax">$A</span><span class="plain-syntax"> 2&gt;&amp;1</span>
<span class="reserved-syntax">    or</span><span class="plain-syntax">: 'launcher produced error messages' </span><span class="function-syntax">$A</span>
</pre>
<p class="commentary">The idea is that if the test is mysteriously crashing at this stage then
running it with <span class="extract"><span class="extract-syntax">-debug</span></span> will divert into the debugger instead, what that
crash can be investigated.
</p>

<p class="commentary firstcommentary"><a id="SP21" class="paragraph-anchor"></a><b>&#167;21.  </b>What happens if a step "fails"? The answer is that nothing happens and the
recipe simply carries on, unless the next line is an <span class="extract"><span class="extract-syntax">or:</span></span> command, as noted
above. So if the shell command doesn't follow Unix conventions with its exit
code, or if we just don't care, we needn't worry that the test will halt. It
will only do so on our explicit instruction.
</p>

<p class="commentary firstcommentary"><a id="SP22" class="paragraph-anchor"></a><b>&#167;22. Matches. </b>Matching simply means comparing the contents of two files.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">match text: A B</span></span>. Here <span class="extract"><span class="extract-syntax">A</span></span> and <span class="extract"><span class="extract-syntax">B</span></span> are text files, and Intest will show
diffs if they disagree.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">match platform text: A B</span></span>. The same, but now forward and backslashes are
counted as being equivalent to each other. This enables filenames printed
out on Windows to be compared with those printed out on other platforms.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">match binary: A B</span></span>. Now they are binaries, so Intest will simply report
that they disagree, if they do.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">match folder: A B</span></span>. This time they are folders (i.e., directories), and
Intest will expect the entire contents (other than any hidden files
beginning with <span class="extract"><span class="extract-syntax">.</span></span>) to agree. This recurses downwards through any
subfolders.
</p>

<p class="commentary">All of these are commands which can pass or fail, so that they can be followed
by an <span class="extract"><span class="extract-syntax">or</span></span> command taking effect only if they fail. If a test fails because
of a failed <span class="extract"><span class="extract-syntax">match</span></span>, then the command line options <span class="extract"><span class="extract-syntax">-diff</span></span> or <span class="extract"><span class="extract-syntax">-bbdiff</span></span>
cause these tools to be invoked on <span class="extract"><span class="extract-syntax">A</span></span> and <span class="extract"><span class="extract-syntax">B</span></span>, the two matched files which
failed.
</p>

<p class="commentary">There are also four Inform-specific forms of matching: <span class="extract"><span class="extract-syntax">match problem</span></span>,
<span class="extract"><span class="extract-syntax">match i6 transcript</span></span>, <span class="extract"><span class="extract-syntax">match frotz transcript</span></span> and <span class="extract"><span class="extract-syntax">match glulxe transcript</span></span>,
which are roughly the same as <span class="extract"><span class="extract-syntax">match text</span></span>, but display differences in a more
contextual way. Details here would be tiresome: see the Intest source code.
</p>

<p class="commentary firstcommentary"><a id="SP23" class="paragraph-anchor"></a><b>&#167;23.  </b>However, the <span class="extract"><span class="extract-syntax">match</span></span> commands have a very useful side-effect if the test
is being run by <span class="extract"><span class="extract-syntax">-curse</span></span>, <span class="extract"><span class="extract-syntax">-bless</span></span> or <span class="extract"><span class="extract-syntax">-rebless</span></span> at the command line. If we
are cursing, then <span class="extract"><span class="extract-syntax">match text: A B</span></span> will delete <span class="extract"><span class="extract-syntax">B</span></span>, the ideal form. If we
are blessing, then <span class="extract"><span class="extract-syntax">match text: A B</span></span> will copy <span class="extract"><span class="extract-syntax">A</span></span> into <span class="extract"><span class="extract-syntax">B</span></span>, thus declaring
that the actual form this time should serve as ideal from now on.
</p>

<p class="commentary firstcommentary"><a id="SP24" class="paragraph-anchor"></a><b>&#167;24.  </b><span class="extract"><span class="extract-syntax">match</span></span> is also just a little forgiving, in that it allows a few not quite
equal texts to "match" each other. In particular:
</p>

<p class="commentary">On a <span class="extract"><span class="extract-syntax">match text: A B</span></span>, a line of A and a line of B will match even if they
disagree about the decimal number appearing in a use of <span class="extract"><span class="extract-syntax">/Tn/</span></span>, where <span class="extract"><span class="extract-syntax">n</span></span>
is that number. For example, these two lines match:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    Opened intest/Workspace/T4/intermediate.txt</span>
<span class="plain-syntax">    Opened intest/Workspace/T11/intermediate.txt</span>
</pre>
<p class="commentary">This example should suggest why &mdash; when Intest is spreading tests across
multiple processors, we cannot predict which thread number a test will run
on; and as a result, we cannot say which sandbox area of the file system
it is allowed to use. That may cause the program under test to print
output which will contain the thread number it is running on. But since
we want to verify that output, we need to allow such output to match. What
happens internally is that both lines are converted to
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    Opened intest/Workspace/Txx/intermediate.txt</span>
</pre>
<p class="commentary">and then, of course, they match exactly. This makes runs of the same test
comparable even when the runs occur on different threads.
</p>

<p class="commentary">This is the only important case of "forgiveness": the others apply only
when matching forms of file specific to Inform. Those make similar
arrangements to ignore the exact build number of Inform when it leaks
out into I7 console output or into story file transcripts.
</p>

<p class="commentary firstcommentary"><a id="SP25" class="paragraph-anchor"></a><b>&#167;25. Files and directories. </b>There is one other commonly used pass/fail command:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">exists: F</span></span>. This passes if the file at <span class="extract"><span class="extract-syntax">F</span></span> exists on disc, and fails otherwise.
For example,
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    exists</span><span class="plain-syntax">: </span><span class="function-syntax">$TRANSCRIPT</span>
<span class="reserved-syntax">    or</span><span class="plain-syntax">: 'no transcript was written'</span>
</pre>
<p class="commentary">(When testing a program which doesn't return exit codes, sometimes the best
way to see whether it worked or not is to see whether it produced any output.)
</p>

<p class="commentary firstcommentary"><a id="SP26" class="paragraph-anchor"></a><b>&#167;26.  </b>In addition, Delia has a very limited ability to write to the file system itself:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    copy</span><span class="plain-syntax">: FROM TO</span>
</pre>
<p class="commentary">copies a file. This should only be used to copy into the work area <span class="extract"><span class="extract-syntax">$WORK</span></span>.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    mkdir</span><span class="plain-syntax">: PATH</span>
</pre>
<p class="commentary">ensures the existence of directory at the given <span class="extract"><span class="extract-syntax">PATH</span></span>. (Again, this should
be used only to make subdirectories of <span class="extract"><span class="extract-syntax">$WORK</span></span>.)
</p>

<p class="commentary">There is intentionally no deletion command. You could fake this easily with
<span class="extract"><span class="extract-syntax">step: rm ...</span></span>, but don't try to clean up the work area yourself: Intest will
handle that automatically.
</p>

<p class="commentary firstcommentary"><a id="SP27" class="paragraph-anchor"></a><b>&#167;27. Conditionals. </b>As noted above, Delia has no loops. But it does have one control construct:
an if/then/else command, working in the obvious way.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    if</span><span class="plain-syntax">: TOKEN EXPRESSION</span>
<span class="plain-syntax">        ...</span>
<span class="reserved-syntax">    else</span>
<span class="plain-syntax">        ...</span>
<span class="reserved-syntax">    endif</span>
</pre>
<p class="commentary">The <span class="extract"><span class="extract-syntax">else</span></span> clause is optional, and these conditionals can be nested in the
usual way.
</p>

<p class="commentary">What the test does is to expand both <span class="extract"><span class="extract-syntax">TOKEN</span></span> and <span class="extract"><span class="extract-syntax">EXPRESSION</span></span>, and then see
if the expanded token matches the regular expression defined by the expanded
expression. That can be just a simple textual match:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    if</span><span class="plain-syntax">: </span><span class="function-syntax">$CASE</span><span class="plain-syntax"> Balloons</span>
</pre>
<p class="commentary">tests if the current test case name is "Balloons". On the other hand,
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    if</span><span class="plain-syntax">: </span><span class="function-syntax">$CASE</span><span class="plain-syntax"> Party-%d+</span>
</pre>
<p class="commentary">would match cases such as <span class="extract"><span class="extract-syntax">Party-12</span></span>, because <span class="extract"><span class="extract-syntax">%d+</span></span> is regular expression
syntax for "one or more digits here".
</p>

<p class="commentary">The regular expression syntax here is a slightly non-standard one used in
the Inform tools, and it's not intended for anything elaborate. <span class="extract"><span class="extract-syntax">%C</span></span>
matches any non-whitespace character, <span class="extract"><span class="extract-syntax">%c</span></span> any character, <span class="extract"><span class="extract-syntax">[abc]</span></span> matches
any of the characters <span class="extract"><span class="extract-syntax">a</span></span>, <span class="extract"><span class="extract-syntax">b</span></span> or <span class="extract"><span class="extract-syntax">c</span></span>, <span class="extract"><span class="extract-syntax">+</span></span> means "one or more", <span class="extract"><span class="extract-syntax">*</span></span> means
"0 or more", but look out for the fact that a space means "any amount
of whitespace".
</p>

<p class="commentary">Moreover, if the <span class="extract"><span class="extract-syntax">EXPRESSION</span></span> is quoted, the quotes are removed again
before the test is performed. Thus:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    if</span><span class="plain-syntax">: </span><span class="function-syntax">$CASE</span><span class="plain-syntax"> 'More Balloons'</span>
</pre>
<p class="commentary">then <span class="extract"><span class="extract-syntax">$CASE</span></span> is tested against the text <span class="extract"><span class="extract-syntax">More Balloons</span></span>, not <span class="extract"><span class="extract-syntax">'More Balloons'</span></span>.
Similarly,
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    if</span><span class="plain-syntax">: </span><span class="function-syntax">$CASE</span><span class="plain-syntax"> ''</span>
</pre>
<p class="commentary">tests if <span class="extract"><span class="extract-syntax">$CASE</span></span> is the empty text.
</p>

<p class="commentary firstcommentary"><a id="SP28" class="paragraph-anchor"></a><b>&#167;28.  </b>An alternative condition is <span class="extract"><span class="extract-syntax">if exists: FILE</span></span> tests if the named file
exists. This can allow for certain checks to be performed only where
there is something to check against, for example.
</p>

<p class="commentary firstcommentary"><a id="SP29" class="paragraph-anchor"></a><b>&#167;29.  </b><span class="extract"><span class="extract-syntax">ifdef: $NAME</span></span> is true if and only if the local variable <span class="extract"><span class="extract-syntax">$NAME</span></span> exists.
Note that this will pass if <span class="extract"><span class="extract-syntax">$NAME</span></span> has the empty text has its value, i.e.,
is currently blank: it will only fail if the variable has never been created.
Note also that some variables are automatically created before the recipe
even begins &mdash; see above.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">ifndef: $NAME</span></span> is the usual opposite of this, i.e., it is true if and only
if <span class="extract"><span class="extract-syntax">$NAME</span></span> has never been created.
</p>

<p class="commentary firstcommentary"><a id="SP30" class="paragraph-anchor"></a><b>&#167;30.  </b>As we have seen, <span class="extract"><span class="extract-syntax">iffail:</span></span> is true if and only if the previous step or
match failed, and <span class="extract"><span class="extract-syntax">ifpass:</span></span> is similarly defined. (Note that these cause
execution to continue where it otherwise would not.)
</p>

<p class="commentary firstcommentary"><a id="SP31" class="paragraph-anchor"></a><b>&#167;31.  </b><span class="extract"><span class="extract-syntax">if showing: ITEM</span></span> is true if and only if the test is being run with
the action <span class="extract"><span class="extract-syntax">-show-ITEM</span></span>. This is useful if you want a recipe to make it
possible to show some elaborate intermediate data which is usually not
needed at all: with <span class="extract"><span class="extract-syntax">if showing:</span></span>, you can have that data created only
when somebody wants to see it.
</p>

<p class="commentary firstcommentary"><a id="SP32" class="paragraph-anchor"></a><b>&#167;32.  </b><span class="extract"><span class="extract-syntax">if compatible: FORMAT COMPATIBILITY</span></span> is true if and only if the
Inform platform text <span class="extract"><span class="extract-syntax">FORMAT</span></span> matches the compatibility text <span class="extract"><span class="extract-syntax">COMPATIBILITY</span></span>.
For example:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    if compatible</span><span class="plain-syntax">: inform6/32 'Glulx only'</span>
</pre>
<p class="commentary">will be true. This is meaningful only when testing Inform, of course.
Errors are generated if either <span class="extract"><span class="extract-syntax">FORMAT</span></span> or <span class="extract"><span class="extract-syntax">COMPATIBILITY</span></span> is malformed.
</p>

<p class="commentary firstcommentary"><a id="SP33" class="paragraph-anchor"></a><b>&#167;33.  </b><span class="extract"><span class="extract-syntax">if format valid: FORMAT</span></span> is true if and only if <span class="extract"><span class="extract-syntax">FORMAT</span></span> is a valid
Inform platform text. For example:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    if format valid</span><span class="plain-syntax">: Python/gil</span>
</pre>
<p class="commentary">is currently not true.
</p>

<p class="commentary firstcommentary"><a id="SP34" class="paragraph-anchor"></a><b>&#167;34.  </b>Suppose the program to be tested produces output which takes a long time
to verify the correctness of. (This is the case for Inform 7, because its
output needs to be fed through Inform 6 and then executed in a virtual
machine before any results can be seen. Both steps take a second or so,
and with 2000 tests and only 3600 seconds in an hour, that's significant.)
</p>

<p class="commentary">An obvious optimisation is to check that the intermediate output matches a
version already known to work. This is not as easy as it seems, though, if
that intermediate output is very large, and if the exact contents of the
output are allowed to change from time to time (provided that the end
functionality does not). Intest provides for this by allowing each test
case to perform one "hash", that is, reducing a text file to a hash code.
These hash codes are then cached between runs of Intest, which always
knows the last hash value found on a run of the test case which passed.
</p>

<p class="commentary">All of that is accomplished with two global variable settings and one
single command. Note that the two globals have to be set outside of Delia;
they aren't dependent on any single test case. They are:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">-set hash_utility HASHPROGRAM</span></span>, which tells Intest what program to use
in order to determine the hash: this is expected to behave like the Unix
tool <span class="extract"><span class="extract-syntax">md5</span></span>, in that the shell command <span class="extract"><span class="extract-syntax">utility FILENAME</span></span> would print a
hash code for the named file and then halt. But if all you want is an <span class="extract"><span class="extract-syntax">md5</span></span>
hash, there is no need to set this variable, because Intest has a built-in
implementation of md5 and can use that instead.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">-set hash_cache FILE</span></span>, which tells Intest where to store known-good hash
values in between runs. If this is not set, hash values may be generated
but are not cached, so that there is little benefit.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">hash: FROM TO</span></span> takes a hash value of the file <span class="extract"><span class="extract-syntax">FROM</span></span> and writes it into
a (very short) file <span class="extract"><span class="extract-syntax">TO</span></span>. This is a pass/fail command, which means that it
can be followed by an <span class="extract"><span class="extract-syntax">or:</span></span>, but perhaps unexpectedly, it fails if the
checksum is the same as the last time this checksum was performed for the
test case in question. That enables something like this:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    hash</span><span class="plain-syntax">: </span><span class="function-syntax">$I6SOURCE</span><span class="plain-syntax"> </span><span class="function-syntax">$WORK</span><span class="plain-syntax">/checksum.txt</span>
<span class="reserved-syntax">    or</span><span class="plain-syntax">: 'passed (matching cached I6 known to work)'</span>
</pre>
<p class="commentary">(Uniquely, the <span class="extract"><span class="extract-syntax">or:</span></span> in this case causes the overall test to pass, not fail.)
Besides being written to the file, the hash value is also stored in the
local variable <span class="extract"><span class="extract-syntax">$HASHCODE</span></span>.
</p>

<p class="commentary firstcommentary"><a id="SP35" class="paragraph-anchor"></a><b>&#167;35.  </b>And finally, a great convenience for testing Inform 7, but useless for
anything else:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">extract: FILE VM</span></span>. This extracts a clean copy of the Inform 7 source text in
the test case and stores it in the <span class="extract"><span class="extract-syntax">FILE</span></span>. For a test case which is a <span class="extract"><span class="extract-syntax">case</span></span>
or <span class="extract"><span class="extract-syntax">problem</span></span>, that's simply a file copy, but for an <span class="extract"><span class="extract-syntax">extension</span></span>, for example,
it's a non-trivial operation. <span class="extract"><span class="extract-syntax">VM</span></span> should be the Inform virtual machine
in question, <span class="extract"><span class="extract-syntax">Z</span></span> or <span class="extract"><span class="extract-syntax">G</span></span>. If the <span class="extract"><span class="extract-syntax">FILE</span></span> contains a command script, this is
automatically written into the local variable <span class="extract"><span class="extract-syntax">$SCRIPT</span></span>.
</p>

<p class="commentary firstcommentary"><a id="SP36" class="paragraph-anchor"></a><b>&#167;36. Cautionary tale about encodings. </b>When we first ported <a href="../../../inweb/docs/index.html" class="internal">inweb</a> and <a href="index.html" class="internal">intest</a> to Windows, we realised that
locale differences meant that some tests weren't portable between MacOS and
Windows. The issue was that the console environment (i.e., the standard
output and standard error stream) was encoded as UTF-8 on MacOS, but ISO Latin1
on Windows: this is the "locale", in operating system jargon.
</p>

<p class="commentary">As a result, a test which recorded the console output on a Mac could not be
compared with the same test on Windows if that output included non-ASCII
characters. That would affect any Delia step written like this:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    step</span><span class="plain-syntax">: insomething/Tangled/insomething whatever &gt;result.txt</span>
</pre>
<p class="commentary">in that the program might be operating identically on these platforms but
still produce a different <span class="extract"><span class="extract-syntax">result.txt</span></span> file on Mac vs Windows, one being
UTF-8 encoded, the other ISO.
</p>

<p class="commentary">To get around this, all of the Inform tools have been given a command-line
setting:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">-locale LOCALE=ENCODING</span></span> where <span class="extract"><span class="extract-syntax">LOCALE</span></span> is one of <span class="extract"><span class="extract-syntax">shell</span></span> or <span class="extract"><span class="extract-syntax">console</span></span>, and
<span class="extract"><span class="extract-syntax">ENCODING</span></span> is one of <span class="extract"><span class="extract-syntax">platform</span></span>, <span class="extract"><span class="extract-syntax">utf-8</span></span> or <span class="extract"><span class="extract-syntax">iso-latin1</span></span>. (The <span class="extract"><span class="extract-syntax">platform</span></span>
encoding means "whatever is normal on the current platform".) Running with the
<span class="extract"><span class="extract-syntax">-verbose</span></span> option in <a href="../../../inweb/docs/index.html" class="internal">inweb</a> or <a href="index.html" class="internal">intest</a> will show the locales being used:
</p>

<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">intest/Tangled/intest</span><span class="ConsoleText-identifier-syntax"> -verbose</span>
<span class="ConsoleText-plain-syntax">    Installation path is /Users/gnelson/dev/intest</span>
<span class="ConsoleText-plain-syntax">    Locales are: shell = utf-8, console = utf-8</span>
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">intest/Tangled/intest</span><span class="ConsoleText-identifier-syntax"> -locale</span><span class="ConsoleText-plain-syntax"> console=iso-latin1</span><span class="ConsoleText-identifier-syntax"> -verbose</span>
<span class="ConsoleText-plain-syntax">    Installation path is /Users/gnelson/dev/intest</span>
<span class="ConsoleText-plain-syntax">    Locales are: shell = utf-8, console = iso-latin1</span>
</pre>
<p class="commentary">It's probably best not to change the <span class="extract"><span class="ConsoleText-extract-syntax">shell</span></span> locale, which affects the
encoding on (a) environment variables, (b) filenames when scanning directories,
and (c) command-line parameters, either in or out. Changing the <span class="extract"><span class="ConsoleText-extract-syntax">console</span></span>
locale, though, effectively makes standard output from an Inform tool conform
to the given locale. So:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    step</span><span class="plain-syntax">: insomething/Tangled/insomething -locale console=utf-8 whatever &gt;result.txt</span>
</pre>
<p class="commentary">would produce the same result on MacOS as on Windows.
</p>

<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="M-tuoc.html">&#10094;</a></li><li class="progresscurrentchapter">M</li><li class="progresssection"><a href="M-iti.html">iti</a></li><li class="progresssection"><a href="M-iatcl.html">iatcl</a></li><li class="progresssection"><a href="M-tuoc.html">tuoc</a></li><li class="progresscurrent">wir</li><li class="progresssection"><a href="M-rc.html">rc</a></li><li class="progresschapter"><a href="P-htpw.html">P</a></li><li class="progresschapter"><a href="1-bsc.html">1</a></li><li class="progresschapter"><a href="2-rf.html">2</a></li><li class="progresschapter"><a href="3-ts.html">3</a></li><li class="progresschapter"><a href="4-tdc.html">4</a></li><li class="progressnext"><a href="M-rc.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>


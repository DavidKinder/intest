<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Writing Intest Recipes</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/ConsoleText-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Intest.png" height=72">
</a></h1>
<ul><li><a href="index.html"><span class="selectedlink">intest</span></a></li>
</ul><h2>Repository</h2><ul>
<li><a href="https://github.com/ganelson/intest"><img src="../docs-assets/github.png" height=18> github</a></li>
</ul><h2>Related Projects</h2><ul>
<li><a href="../../../inweb/docs/index.html">inweb</a></li>
<li><a href="../../../inform/docs/index.html">inform</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Writing Intest Recipes' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="index.html">intest</a></li><li><a href="index.html#M">Manual</a></li><li><b>Writing Intest Recipes</b></li></ul></div>
<p class="purpose">A guide to writing in Delia, Intest's recipe language.</p>

<ul class="toc"><li><a href="M-wir.html#SP1">&#167;1. About test cases</a></li><li><a href="M-wir.html#SP3">&#167;3. Recipe files</a></li><li><a href="M-wir.html#SP7">&#167;7. Writing Delia</a></li><li><a href="M-wir.html#SP23">&#167;23. Cautionary tale about encodings</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1"></a><b>&#167;1. About test cases. </b>To use any of this, at least one test case is required, and there will
probably be many. The typical arrangement is that each test case has a
name &mdash; say, "sorting" &mdash; and comes with a file of input for the program
being tested &mdash; say, <span class="extract"><span class="extract-syntax">sorting.txt</span></span>. Intest therefore requires each test
case to be specified by a text file. (Its contents don't have to be the
input to the program, though, and there are even situations where it's
convenient to make it an empty text file existing only for the sake of
its name.)
</p>

<p class="commentary">So you need to create a text file for each test case. This should be
called <span class="extract"><span class="extract-syntax">NAME.txt</span></span>, where <span class="extract"><span class="extract-syntax">NAME</span></span> is the test case name. There are some
rules about these names:
</p>

<ul class="items"><li>(a) They are case-sensitive, so "Frogs" is different from "frogs". This
is true even if your file system is case-insensitive, as it probably is.
Your computer may regard <span class="extract"><span class="extract-syntax">Frogs.txt</span></span> and <span class="extract"><span class="extract-syntax">frogs.txt</span></span> as the same file,
but to Intest those names would refer to different cases. It follows
that you can't practicably have two case names which are the same except
for casing.
</li><li>(b) The names <span class="extract"><span class="extract-syntax">all</span></span>, <span class="extract"><span class="extract-syntax">examples</span></span>, <span class="extract"><span class="extract-syntax">extensions</span></span>, <span class="extract"><span class="extract-syntax">problems</span></span>, <span class="extract"><span class="extract-syntax">cases</span></span>, and
<span class="extract"><span class="extract-syntax">maps</span></span> are reserved for Intest wildcards, and can't be used.
</li><li>(c) A name cannot begin with a dash <span class="extract"><span class="extract-syntax">-</span></span>, a caret <span class="extract"><span class="extract-syntax">^</span></span>, a question mark <span class="extract"><span class="extract-syntax">?</span></span>,
an exclamation mark <span class="extract"><span class="extract-syntax">!</span></span>, an open bracket <span class="extract"><span class="extract-syntax">(</span></span>, a square bracket <span class="extract"><span class="extract-syntax">[</span></span>,
a full stop <span class="extract"><span class="extract-syntax">.</span></span>, an underscore <span class="extract"><span class="extract-syntax">_</span></span>, or a digit. It's probably best to
start with a letter.
</li><li>(d) A name cannot consist only of a number or a single letter.
</li><li>(e) A name cannot contain a colon or a slash, forwards or backwards, and
must contain only filename-safe characters. It can contain white space, but
your life will be easier if it doesn't. Similarly, best to avoid accented
letters or emoji.
</li></ul>
<p class="commentary">If you are testing Inform 7, it is conventional that a test case name which
ends in <span class="extract"><span class="extract-syntax">-G</span></span> is one needing to be compiled for the Glulx virtual machine,
and a name which ends in <span class="extract"><span class="extract-syntax">-Z</span></span> needs to be compiled for the Z-machine.
</p>

<p class="commentary firstcommentary"><a id="SP2"></a><b>&#167;2.  </b>There are five types of case, but three are used only for testing Inform 7,
and can be ignored by everybody else. The important ones are:
</p>

<ul class="items"><li>(a) "case" &mdash; where the expectation is that the program being tested will
accept this test case and not produce errors, and
</li><li>(b) "problem" &mdash; where the expectation is that the program will reject it
with error messages.
</li></ul>
<p class="commentary">The other three are:
</p>

<ul class="items"><li>(c) "example" &mdash; a "case", but written into an Inform documentation file,
a format which takes a bit of decoding.
</li><li>(d) "extension" &mdash; a "case", but one of the examples from an Inform extension
file, a format which takes even more decoding.
</li><li>(e) "map" &mdash; a "case", but to do with spatial maps drawn out from Inform
source text, in a way not worth going into here.
</li></ul>
<p class="commentary firstcommentary"><a id="SP3"></a><b>&#167;3. Recipe files. </b>As previously noted, Intest needs a recipe file in order to run in any
useful fashion; by default, Intest expects to find this file at
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    PROJECT/Tests/PROJECT.intest</span>
</pre>
<p class="commentary">where <span class="extract"><span class="extract-syntax">PROJECT</span></span> is the name of the tested project's home directory. But
with the <span class="extract"><span class="extract-syntax">-using</span></span> switch at the command line, an alternative file cam be
used somewhere else.
</p>

<p class="commentary">An Intest recipe file is a UTF-8 encoded text file. It is a list of commands
which, for the most part, tell Intest where to find test cases, and then
definitions of recipes, which Intest can then use to test them.
</p>

<p class="commentary">Here is a typical simple recipe file. It begins with a command, telling Intest
the location of a directory of test cases which will have type <span class="extract"><span class="extract-syntax">case</span></span>, and
then gives a single recipe, which Intest will use on whatever cases it
discovered in that directory.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">-cases</span><span class="plain-syntax"> 'inform7/kinds-test/Tests/Test Cases'</span>

<span class="identifier-syntax">-recipe</span>

<span class="reserved-syntax">    set</span><span class="plain-syntax">: </span><span class="function-syntax">$A</span><span class="plain-syntax"> = </span><span class="function-syntax">$PATH</span><span class="plain-syntax">/_Results_Actual/</span><span class="function-syntax">$CASE</span><span class="plain-syntax">.txt</span>
<span class="reserved-syntax">    set</span><span class="plain-syntax">: </span><span class="function-syntax">$I</span><span class="plain-syntax"> = </span><span class="function-syntax">$PATH</span><span class="plain-syntax">/_Results_Ideal/</span><span class="function-syntax">$CASE</span><span class="plain-syntax">.txt</span>

<span class="reserved-syntax">    step</span><span class="plain-syntax">: inform7/kinds-test/Tangled/kinds-test -test-</span><span class="function-syntax">$CASE</span><span class="plain-syntax"> </span><span class="function-syntax">$PATH</span><span class="plain-syntax">/</span><span class="function-syntax">$CASE</span><span class="plain-syntax">.txt &gt;</span><span class="function-syntax">$A</span><span class="plain-syntax"> 2&gt;&amp;1</span>
<span class="reserved-syntax">    or</span><span class="plain-syntax">: 'produced errors in kinds-test' </span><span class="function-syntax">$A</span>

<span class="reserved-syntax">    show</span><span class="plain-syntax">: </span><span class="function-syntax">$A</span>

<span class="reserved-syntax">    exists</span><span class="plain-syntax">: </span><span class="function-syntax">$I</span>
<span class="reserved-syntax">    or</span><span class="plain-syntax">: 'passed without errors but no blessed output existed'</span>

<span class="reserved-syntax">    match text</span><span class="plain-syntax">: </span><span class="function-syntax">$A</span><span class="plain-syntax"> </span><span class="function-syntax">$I</span>
<span class="reserved-syntax">    or</span><span class="plain-syntax">: 'produced incorrect output'</span>

<span class="identifier-syntax">-end</span>
</pre>
<p class="commentary firstcommentary"><a id="SP4"></a><b>&#167;4.  </b>As that example suggests, each line is a command, and each command begins
with a dash <span class="extract"><span class="extract-syntax">-</span></span>, except that blank lines are ignored. So are comment lines,
beginning with exclamation marks <span class="extract"><span class="extract-syntax">!</span></span>.
</p>

<p class="commentary">A recipe file normally begins by declaring where all the cases live:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">-case F</span></span>, where <span class="extract"><span class="extract-syntax">F</span></span> is a filename. Make this a test case of type "case".
Similarly for <span class="extract"><span class="extract-syntax">-problem</span></span>, <span class="extract"><span class="extract-syntax">-example</span></span>, <span class="extract"><span class="extract-syntax">-extension</span></span>, and <span class="extract"><span class="extract-syntax">-map</span></span>.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">-cases D</span></span>, where <span class="extract"><span class="extract-syntax">D</span></span> is a directory name. Make every validly named text file
in this directory a test case of type "case". Similarly for <span class="extract"><span class="extract-syntax">-problems</span></span>,
<span class="extract"><span class="extract-syntax">-examples</span></span>, <span class="extract"><span class="extract-syntax">-extensions</span></span>, and <span class="extract"><span class="extract-syntax">-maps</span></span>.
</p>

<p class="commentary">Each case has a recipe assigned to it. Often the same recipe will be assigned
to every case, but not all always. The recipe is by default the one called
just <span class="extract"><span class="extract-syntax">[Recipe]</span></span> (see below), but declaring <span class="extract"><span class="extract-syntax">-case [NAME] F</span></span>, <span class="extract"><span class="extract-syntax">-cases [NAME] D</span></span>,
and so on, makes the recipe for those case(s) <span class="extract"><span class="extract-syntax">[NAME]</span></span> instead.
</p>

<p class="commentary firstcommentary"><a id="SP5"></a><b>&#167;5.  </b>A recipe file must also define at least one recipe. There are two ways
to do this:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">-recipe [NAME] FILE</span></span> says that the recipe <span class="extract"><span class="extract-syntax">[NAME]</span></span> is defined in the given
text file. This is the old-fashioned way; experienced showed that it was
more convenient to write &mdash;
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">-recipe [NAME]</span></span> followed by a definition written in the main file itself:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    -recipe [NAME]</span>
<span class="plain-syntax">        ...</span>
<span class="plain-syntax">        ...</span>
<span class="plain-syntax">    -end</span>
</pre>
<p class="commentary">where the definition occupies the lines in between the <span class="extract"><span class="extract-syntax">-recipe</span></span> line and the
<span class="extract"><span class="extract-syntax">-end</span></span> line. (Those lines in between are not commands and don't start with
dashes.)
</p>

<p class="commentary">If no <span class="extract"><span class="extract-syntax">[NAME]</span></span> is given, the name is assumed to be just <span class="extract"><span class="extract-syntax">[Recipe]</span></span>.
</p>

<p class="commentary firstcommentary"><a id="SP6"></a><b>&#167;6.  </b>Those are the only essentials, but two other dashed commands exist:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">-set VARIABLE VALUE</span></span>. Variables are more usually set inside recipes, but
they can also be set here, as global variables whose values apply whatever
recipe is used. See the notes on variables in the section on recipes below.
(The variable, being global, will be called <span class="extract"><span class="extract-syntax">$$VARIABLE</span></span> in Delia code.)
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">-if PLATFORM</span></span> and <span class="extract"><span class="extract-syntax">-endif</span></span>. Dashed commands in between these lines will be
followed only if the variable <span class="extract"><span class="extract-syntax">$$platform</span></span> matches the value <span class="extract"><span class="extract-syntax">PLATFORM</span></span>. This
value will be something like <span class="extract"><span class="extract-syntax">osx</span></span>, <span class="extract"><span class="extract-syntax">windows</span></span>, or <span class="extract"><span class="extract-syntax">android</span></span>.
</p>

<p class="commentary firstcommentary"><a id="SP7"></a><b>&#167;7. Writing Delia. </b>Recipe definitions are written in a very simple mini-language called Delia,
for reasons which English users of Intest will appreciate. Had Intest been
written by an American, it would have been called Julia.
</p>

<p class="commentary">In Delia, once again, blanks lines and lines beginning with exclamation
marks <span class="extract"><span class="extract-syntax">!</span></span> are ignored. All other lines must have the form
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    command</span><span class="plain-syntax">: token1 ... tokenN</span>
</pre>
<p class="commentary">where different commands need different numbers of tokens. Most commands
are a single word, but a few are more than one. There are sometimes no
tokens at all, in which case no colon is required:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    command</span>
</pre>
<p class="commentary">The command and its tokens must occupy a single line and no comment is
allowed at the end of it. Quotation marks can be used to make multiple words
a single token; thus:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    exists</span><span class="plain-syntax">: 'My Tests/output.txt'</span>
</pre>
<p class="commentary">is a command plus a single token, not two. A backslash can be used to escape
the quotation mark when inside quotes. A token which begins with a backtick,
<span class="extract"><span class="extract-syntax">`thus</span></span>, is marked as not to be quoted: see below.
</p>

<p class="commentary firstcommentary"><a id="SP8"></a><b>&#167;8.  </b>Delia has just one data structure, a set of named variables. Each of these
has a textual value; usually those represent filenames or parts of filenames,
but not necessarily.
</p>

<p class="commentary">There are a very few "global" variables, written with a double dollar sign.
Global means they have the same value regardless of which test case is being
worked on. One global is automatically defined: <span class="extract"><span class="extract-syntax">$$platform</span></span>, as mentioned
above, which is a string such as <span class="extract"><span class="extract-syntax">osx</span></span> or <span class="extract"><span class="extract-syntax">windows</span></span>. It is always better
to avoid using this where possible. All other global variables are created
by the <span class="extract"><span class="extract-syntax">-set</span></span> command at the top of the recipe file: see above.
</p>

<p class="commentary">Other variables are "local" and written with a single dollar sign. These have
different values for different test cases. For every Delia recipe, three are
automatically defined:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">$CASE</span></span> is the name of the test case;
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">$PATH</span></span> is the pathname to the directory which the test case is in;
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">$TYPE</span></span> is the type of test case this is: <span class="extract"><span class="extract-syntax">case</span></span>, <span class="extract"><span class="extract-syntax">problem</span></span>, <span class="extract"><span class="extract-syntax">example</span></span>,
<span class="extract"><span class="extract-syntax">extension</span></span> or <span class="extract"><span class="extract-syntax">map</span></span>;
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">$WORK</span></span> is the pathname of a directory set aside by Intest for any intermediate
files we might need to produce during the test process &mdash; these must all be
temporary files we can happily lose when the test is completed. The real
usefulness of this comes when Intest is running a batch of tests across
multiple threads, because those threads each need their own independent work
area to avoid stepping on each other's feet. Provided the recipe uses <span class="extract"><span class="extract-syntax">$WORK</span></span>,
it never needs to think about this complication.
</p>

<p class="commentary firstcommentary"><a id="SP9"></a><b>&#167;9.  </b>The real usefulness of variables is that they are automatically substituted
into tokens. When Delia reads the token <span class="extract"><span class="extract-syntax">$PATH/$CASE.txt</span></span>, for example,
it substitutes in the values of <span class="extract"><span class="extract-syntax">$PATH</span></span> and <span class="extract"><span class="extract-syntax">$CASE</span></span> to produce something
like <span class="extract"><span class="extract-syntax">zap/Tests/planets.txt</span></span>. This process is called "expansion".
</p>

<p class="commentary">For example, when a new variable is created with:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    set</span><span class="plain-syntax">: </span><span class="function-syntax">$NAME</span><span class="plain-syntax"> = VALUE</span>
</pre>
<p class="commentary">the <span class="extract"><span class="extract-syntax">VALUE</span></span> is expanded before being written into the new variable <span class="extract"><span class="extract-syntax">$NAME</span></span>.
</p>

<p class="commentary">A wrinkle here is that if the setting value has multiple tokens:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    set</span><span class="plain-syntax">: </span><span class="function-syntax">$NAME</span><span class="plain-syntax"> = VALUE1 VALUE2 ...</span>
</pre>
<p class="commentary">then they are each "quote-expanded", rather than being simply "expanded".
This basically means that the value is meant to be used in place of a string
of tokens, rather than as a fragment or the whole of a single token.
For example:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    set</span><span class="plain-syntax">: </span><span class="function-syntax">$OPTIONS</span><span class="plain-syntax"> = -no-warnings -p=10 -to </span><span class="function-syntax">$FILE</span><span class="plain-syntax">.txt</span>
</pre>
<p class="commentary">sets the value to be
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    '-no-warnings' '-p=10' '-verbose' '-to' 'My File.txt'</span>
</pre>
<p class="commentary">This precaution is in case, as happened in this example, expansion of one of
the tokens, <span class="extract"><span class="extract-syntax">$FILE.txt</span></span>, brought in new white space &mdash; here, the space between
"My" and "File".
</p>

<p class="commentary">Quote-expansion is not always what we want. For example, suppose we further
defined:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    set</span><span class="plain-syntax">: </span><span class="function-syntax">$MOREOPTIONS</span><span class="plain-syntax"> = </span><span class="function-syntax">$OPTIONS</span><span class="plain-syntax"> -lang=en-uk</span>
</pre>
<p class="commentary">We would then get the value:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    '\'-no-warnings\' \'-p=10\' \'-verbose\' \'-to\' \'My File.txt\'' '-lang=en-uk'</span>
</pre>
<p class="commentary">which of course is wrong. We avoid this using a backtick to suppress quote
expansion of the first token:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    set</span><span class="plain-syntax">: </span><span class="function-syntax">$MOREOPTIONS</span><span class="plain-syntax"> = `</span><span class="function-syntax">$OPTIONS</span><span class="plain-syntax"> -lang=en-uk</span>
</pre>
<p class="commentary">which gets it right:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    '-no-warnings' '-p=10' '-verbose' '-to' 'My File.txt' '-lang=en-uk'</span>
</pre>
<p class="commentary">Note that quote expansion respects the Unix shell redirection markers like
<span class="extract"><span class="extract-syntax">&gt;file</span></span> or <span class="extract"><span class="extract-syntax">2&gt;&amp;1</span></span>, quoting just the file parts.
</p>

<p class="commentary">Quote-expansion also supports one more feature: the token <span class="extract"><span class="extract-syntax">$[filename$]</span></span>
expands to the (tokenised and further expanded) contents of the file named.
Thus for example if the file <span class="extract"><span class="extract-syntax">Frog.txt</span></span> contains the words "never turn your
back on a frog", then
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    $[Frog.txt$]</span>
</pre>
<p class="commentary">will quote-expand to:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    'never' 'turn' 'your' 'back' 'on' 'a' 'frog'</span>
</pre>
<p class="commentary firstcommentary"><a id="SP10"></a><b>&#167;10.  </b>Note that the filename is itself expanded before use, so that it can be
defined using variables. This can be very useful when we want to test a
program which takes its input mainly in the form of command-line arguments,
rather than from a file. See the example supplied with Intest for testing
"dc", the very old-school reverse Polish notation calculator supplied with
most Unix systems (including MacOS). In that example, a test case such as
<span class="extract"><span class="extract-syntax">dc/Tests/Cases/plus.txt</span></span> contains what to put on the command line when
running dc:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    -e '1 1 + p'</span>
</pre>
<p class="commentary">The important step in the recipe for using this then reads:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    step</span><span class="plain-syntax">: dc $[</span><span class="function-syntax">$PATH</span><span class="plain-syntax">/</span><span class="function-syntax">$CASE</span><span class="plain-syntax">.txt$]</span>
</pre>
<p class="commentary">and this causes Intest to run the command:
</p>

<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">dc</span><span class="ConsoleText-identifier-syntax"> -e</span><span class="ConsoleText-plain-syntax"> '1 1 + p'</span>
</pre>
<p class="commentary">which produces the concise output "2".
</p>

<p class="commentary firstcommentary"><a id="SP11"></a><b>&#167;11.  </b>A Delia recipe runs from the first line onwards. There are no loops,
functions or subroutines, but there are conditionals. The run ends
as soon as one of the three commands <span class="extract"><span class="ConsoleText-extract-syntax">pass</span></span>, <span class="extract"><span class="ConsoleText-extract-syntax">fail</span></span> and <span class="extract"><span class="ConsoleText-extract-syntax">or</span></span> is executed.
</p>

<p class="commentary">Testing consists mainly of running some programs, "steps", and then
checking that their output is correct, "matching". There are two sorts
of step:
</p>

<p class="commentary"><span class="extract"><span class="ConsoleText-extract-syntax">step: COMMAND</span></span>. Runs the shell command <span class="extract"><span class="ConsoleText-extract-syntax">COMMAND</span></span>. The step passes if the
command returns the exit code 0, which for Unix utilities conventionally
means that no errors occurred. It fails on all non-zero exit codes.
</p>

<p class="commentary"><span class="extract"><span class="ConsoleText-extract-syntax">fail step: COMMAND</span></span>. The same, but this time expecting a non-zero exit
code, and failing on zero.
</p>

<p class="commentary">What happens if a step "fails"? The answer is that nothing happens and
the recipe simply carries on, unless the next line is an <span class="extract"><span class="ConsoleText-extract-syntax">or:</span></span> command,
as we shall see next. So if the shell command doesn't follow Unix
conventions with its exit code, or if we just don't care, we needn't
worry that the test will halt. It will only do so on our explicit
instruction.
</p>

<p class="commentary firstcommentary"><a id="SP12"></a><b>&#167;12.  </b>Matching simply means comparing the contents of two files.
</p>

<p class="commentary"><span class="extract"><span class="ConsoleText-extract-syntax">match text: A B</span></span>. Here <span class="extract"><span class="ConsoleText-extract-syntax">A</span></span> and <span class="extract"><span class="ConsoleText-extract-syntax">B</span></span> are text files, and Intest will show
diffs if they disagree.
</p>

<p class="commentary"><span class="extract"><span class="ConsoleText-extract-syntax">match binary: A B</span></span>. Now they are binaries, so Intest will simply report
that they disagree, if they do.
</p>

<p class="commentary"><span class="extract"><span class="ConsoleText-extract-syntax">match folder: A B</span></span>. This time they are folders (i.e., directories), and
Intest will expect the entire contents (other than any hidden files
beginning with <span class="extract"><span class="ConsoleText-extract-syntax">.</span></span>) to agree. This recurses downwards through any
subfolders.
</p>

<p class="commentary">All of these are commands which can pass or fail, so that they can be followed
by an <span class="extract"><span class="ConsoleText-extract-syntax">or</span></span> command taking effect only if they fail. If a test fails because
of a failed <span class="extract"><span class="ConsoleText-extract-syntax">match</span></span>, then the command line options <span class="extract"><span class="ConsoleText-extract-syntax">-diff</span></span> or <span class="extract"><span class="ConsoleText-extract-syntax">-bbdiff</span></span>
cause these tools to be invoked on <span class="extract"><span class="ConsoleText-extract-syntax">A</span></span> and <span class="extract"><span class="ConsoleText-extract-syntax">B</span></span>, the two matched files which
failed.
</p>

<p class="commentary">There are also three Inform-specific forms of matching: <span class="extract"><span class="ConsoleText-extract-syntax">match problem</span></span>,
<span class="extract"><span class="ConsoleText-extract-syntax">match frotz transcript</span></span> and <span class="extract"><span class="ConsoleText-extract-syntax">match glulxe transcript</span></span>, which are roughly
the same as <span class="extract"><span class="ConsoleText-extract-syntax">match text</span></span>, but display differences in a more contextual way.
Details here would be tiresome: see the Intest source code.
</p>

<p class="commentary firstcommentary"><a id="SP13"></a><b>&#167;13.  </b>However, the <span class="extract"><span class="ConsoleText-extract-syntax">match</span></span> commands have a very useful side-effect if the test
is being run by <span class="extract"><span class="ConsoleText-extract-syntax">-curse</span></span>, <span class="extract"><span class="ConsoleText-extract-syntax">-bless</span></span> or <span class="extract"><span class="ConsoleText-extract-syntax">-rebless</span></span> at the command line. If we
are cursing, then <span class="extract"><span class="ConsoleText-extract-syntax">match text: A B</span></span> will delete <span class="extract"><span class="ConsoleText-extract-syntax">B</span></span>, the ideal form. If we
are blessing, then <span class="extract"><span class="ConsoleText-extract-syntax">match text: A B</span></span> will copy <span class="extract"><span class="ConsoleText-extract-syntax">A</span></span> into <span class="extract"><span class="ConsoleText-extract-syntax">B</span></span>, thus declaring
that the actual form this time should serve as ideal from now on.
</p>

<p class="commentary firstcommentary"><a id="SP14"></a><b>&#167;14.  </b><span class="extract"><span class="ConsoleText-extract-syntax">match</span></span> is also just a little forgiving, in that it allows a few not quite
equal texts to "match" each other. In particular:
</p>

<p class="commentary">On a <span class="extract"><span class="ConsoleText-extract-syntax">match text: A B</span></span>, a line of A and a line of B will match even if they
disagree about the decimal number appearing in a use of <span class="extract"><span class="ConsoleText-extract-syntax">/Tn/</span></span>, where <span class="extract"><span class="ConsoleText-extract-syntax">n</span></span>
is that number. For example, these two lines match:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    Opened intest/Workspace/T4/intermediate.txt</span>
<span class="plain-syntax">    Opened intest/Workspace/T11/intermediate.txt</span>
</pre>
<p class="commentary">This example should suggest why &mdash; when Intest is spreading tests across
multiple processors, we cannot predict which thread number a test will run
on; and as a result, we cannot say which sandbox area of the file system
it is allowed to use. That may cause the program under test to print
output which will contain the thread number it is running on. But since
we want to verify that output, we need to allow such output to match. What
happens internally is that both lines are converted to
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    Opened intest/Workspace/Txx/intermediate.txt</span>
</pre>
<p class="commentary">and then, of course, they match exactly. This makes runs of the same test
comparable even when the runs occur on different threads.
</p>

<p class="commentary">This is the only important case of "forgiveness": the others apply only
when matching forms of file specific to Inform. Those make similar
arrangements to ignore the exact build number of Inform when it leaks
out into I7 console output or into story file transcripts.
</p>

<p class="commentary firstcommentary"><a id="SP15"></a><b>&#167;15.  </b>There is one other commonly used pass/fail command:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">exists: F</span></span>. This passes if the file at <span class="extract"><span class="extract-syntax">F</span></span> exists on disc, and fails otherwise.
For example,
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    exists</span><span class="plain-syntax">: </span><span class="function-syntax">$TRANSCRIPT</span>
<span class="reserved-syntax">    or</span><span class="plain-syntax">: 'no transcript was written'</span>
</pre>
<p class="commentary">(When testing a program which doesn't return exit codes, sometimes the best
way to see whether it worked or not is to see whether it produced any output.)
</p>

<p class="commentary firstcommentary"><a id="SP16"></a><b>&#167;16.  </b>The <span class="extract"><span class="extract-syntax">debugger: ...</span></span> command is set out exactly like <span class="extract"><span class="extract-syntax">step: ...</span></span>, but runs
only when the test is being run by the <span class="extract"><span class="extract-syntax">-debug</span></span> action. This is then used to
trigger the <span class="extract"><span class="extract-syntax">lldb</span></span> debugger; see the Inform 7 test recipe for more.
</p>

<p class="commentary firstcommentary"><a id="SP17"></a><b>&#167;17.  </b>These are the three main "stopping commands", which do cause the test to halt:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">pass: 'NOTE'</span></span>. Stops the test and marks it a success. The text <span class="extract"><span class="extract-syntax">'NOTE'</span></span>
is optional, and is a summary used when Intest prints its results.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">fail: 'NOTE'</span></span>. Stops the test and marks it a failure. The text <span class="extract"><span class="extract-syntax">'NOTE'</span></span>
is optional, and is a summary used when Intest prints its results.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">or: 'NOTE' FILE</span></span>. If the step performed immediately before this line
failed, this stops the whole test and marks it as a failure. The <span class="extract"><span class="extract-syntax">FILE</span></span>,
which is optional, is then printed out when Intest describes what went
wrong. For example:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    step</span><span class="plain-syntax">: dc -e </span><span class="function-syntax">$EXPRESSION</span>
<span class="reserved-syntax">    or</span><span class="plain-syntax">: 'dc produced an error'</span>
</pre>
<p class="commentary firstcommentary"><a id="SP18"></a><b>&#167;18.  </b>But there are actually a few others:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">show F</span></span>. Stops the test and prints out the file <span class="extract"><span class="extract-syntax">F</span></span>, but only if the test
is being run by the <span class="extract"><span class="extract-syntax">-show</span></span> command: otherwise, does nothing and carries on.
</p>

<p class="commentary">This is how we implement the <span class="extract"><span class="extract-syntax">-show</span></span> command-line feature of Intest. Typically,
it's used to show the full console output from the program being tested. For
Inform testing only, there's a related:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">show i6: F</span></span>. The same, but for the <span class="extract"><span class="extract-syntax">-show-i6</span></span> command instead of <span class="extract"><span class="extract-syntax">-show</span></span>.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">show transcript: F</span></span>. The same, but for the <span class="extract"><span class="extract-syntax">-show-t</span></span> command instead of <span class="extract"><span class="extract-syntax">-show</span></span>.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">show:</span></span>, <span class="extract"><span class="extract-syntax">show i6:</span></span> and <span class="extract"><span class="extract-syntax">show transcript:</span></span> all fail if the file <span class="extract"><span class="extract-syntax">F</span></span> does not
exist, but this possibility can be picked up by placing an <span class="extract"><span class="extract-syntax">or:</span></span> after them.
</p>

<p class="commentary firstcommentary"><a id="SP19"></a><b>&#167;19.  </b>As noted above, Delia has no loops. But it does have one control construct:
an if/then/else command, working in the obvious way.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    if matches</span><span class="plain-syntax">: TOKEN EXPRESSION</span>
<span class="plain-syntax">        ...</span>
<span class="reserved-syntax">    else</span>
<span class="plain-syntax">        ...</span>
<span class="reserved-syntax">    endif</span>
</pre>
<p class="commentary">The <span class="extract"><span class="extract-syntax">else</span></span> clause is optional, and these conditionals can be nested in the
usual way.
</p>

<p class="commentary">What the test does is to expand both <span class="extract"><span class="extract-syntax">TOKEN</span></span> and <span class="extract"><span class="extract-syntax">EXPRESSION</span></span>, and then see
if the expanded token matches the regular expression defined by the expanded
expression. That can be just a simple textual match:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    if matches</span><span class="plain-syntax">: </span><span class="function-syntax">$CASE</span><span class="plain-syntax"> Balloons</span>
</pre>
<p class="commentary">tests if the current test case name is "Balloons". On the other hand,
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    if matches</span><span class="plain-syntax">: </span><span class="function-syntax">$CASE</span><span class="plain-syntax"> Party-%d+</span>
</pre>
<p class="commentary">would match cases such as <span class="extract"><span class="extract-syntax">Party-12</span></span>, because <span class="extract"><span class="extract-syntax">%d+</span></span> is regular expression
syntax for "one or more digits here".
</p>

<p class="commentary firstcommentary"><a id="SP20"></a><b>&#167;20.  </b>That's all of the important commands covered, but Delia has a small
miscellany of other features. It has a very limited ability to write to
the file system itself:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    copy</span><span class="plain-syntax">: FROM TO</span>
</pre>
<p class="commentary">copies a file. This should only be used to copy into the work area <span class="extract"><span class="extract-syntax">$WORK</span></span>.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    mkdir</span><span class="plain-syntax">: PATH</span>
</pre>
<p class="commentary">ensures the existence of directory at the given <span class="extract"><span class="extract-syntax">PATH</span></span>. (Again, this should
be used only to make subdirectories of <span class="extract"><span class="extract-syntax">$WORK</span></span>.) There is intentionally no
<span class="extract"><span class="extract-syntax">rm</span></span> command. You could fake this easily with <span class="extract"><span class="extract-syntax">step: rm ...</span></span>, but don't
try to clean up the work area yourself: Intest will handle that automatically.
</p>

<p class="commentary firstcommentary"><a id="SP21"></a><b>&#167;21.  </b>Suppose the program to be tested produces output which takes a long time
to verify the correctness of. (This is the case for Inform 7, because its
output needs to be fed through Inform 6 and then executed in a virtual
machine before any results can be seen. Both steps take a second or so,
and with 2000 tests and only 3600 seconds in an hour, that's significant.)
</p>

<p class="commentary">An obvious optimisation is to check that the intermediate output matches a
version already known to work. This is not as easy as it seems, though, if
that intermediate output is very large, and if the exact contents of the
output are allowed to change from time to time (provided that the end
functionality does not). Intest provides for this by allowing each test
case to perform one "hash", that is, reducing a text file to a hash code.
These hash codes are then cached between runs of Intest, which always
knows the last hash value found on a run of the test case which passed.
</p>

<p class="commentary">All of that is accomplished with two global variable settings and one
single command. Note that the two globals have to be set outside of Delia;
they aren't dependent on any single test case. They are:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">-set hash_utility HASHPROGRAM</span></span>, which tells Intest what program to use
in order to determine the hash: a good choice is <span class="extract"><span class="extract-syntax">md5</span></span>, if it's available.
If this is not set, the Delia <span class="extract"><span class="extract-syntax">hash</span></span> command (see below) does nothing.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">-set hash_cache FILE</span></span>, which tells Intest where to store known-good hash
values in between runs. If this is not set, hash values may be generated
but are not cached, so that there is little benefit.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">hash: FROM TO</span></span> takes a hash value of the file <span class="extract"><span class="extract-syntax">FROM</span></span> and writes it into
a (very short) file <span class="extract"><span class="extract-syntax">TO</span></span>. This is a pass/fail command, which means that it
can be followed by an <span class="extract"><span class="extract-syntax">or:</span></span>, but perhaps unexpectedly, it fails if the
checksum is the same as the last time this checksum was performed for the
test case in question. That enables something like this:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    hash</span><span class="plain-syntax">: </span><span class="function-syntax">$I6SOURCE</span><span class="plain-syntax"> </span><span class="function-syntax">$WORK</span><span class="plain-syntax">/checksum.txt</span>
<span class="reserved-syntax">    or</span><span class="plain-syntax">: 'passed (matching cached I6 known to work)'</span>
</pre>
<p class="commentary">(Uniquely, the <span class="extract"><span class="extract-syntax">or:</span></span> in this case causes the overall test to pass, not fail.)
Besides being written to the file, the hash value is also stored in the
local variable <span class="extract"><span class="extract-syntax">$HASHCODE</span></span>.
</p>

<p class="commentary firstcommentary"><a id="SP22"></a><b>&#167;22.  </b>And finally, a great convenience for testing Inform 7, but useless for
anything else:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">extract: FILE VM</span></span>. This extracts a clean copy of the Inform 7 source text in
the test case and stores it in the <span class="extract"><span class="extract-syntax">FILE</span></span>. For a test case which is a <span class="extract"><span class="extract-syntax">case</span></span>
or <span class="extract"><span class="extract-syntax">problem</span></span>, that's simply a file copy, but for an <span class="extract"><span class="extract-syntax">extension</span></span>, for example,
it's a non-trivial operation. <span class="extract"><span class="extract-syntax">VM</span></span> should be the Inform virtual machine
in question, <span class="extract"><span class="extract-syntax">Z</span></span> or <span class="extract"><span class="extract-syntax">G</span></span>. If the <span class="extract"><span class="extract-syntax">FILE</span></span> contains a command script, this is
automatically written into the local variable <span class="extract"><span class="extract-syntax">$SCRIPT</span></span>.
</p>

<p class="commentary firstcommentary"><a id="SP23"></a><b>&#167;23. Cautionary tale about encodings. </b>When we first ported <a href="../../../inweb/docs/index.html" class="internal">inweb</a> and <a href="index.html" class="internal">intest</a> to Windows, we realised that
locale differences meant that some tests weren't portable between MacOS and
Windows. The issue was that the console environment (i.e., the standard
output and standard error stream) was encoded as UTF-8 on MacOS, but ISO Latin1
on Windows: this is the "locale", in operating system jargon.
</p>

<p class="commentary">As a result, a test which recorded the console output on a Mac could not be
compared with the same test on Windows if that output included non-ASCII
characters. That would affect any Delia step written like this:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    step</span><span class="plain-syntax">: insomething/Tangled/insomething whatever &gt;result.txt</span>
</pre>
<p class="commentary">in that the program might be operating identically on these platforms but
still produce a different <span class="extract"><span class="extract-syntax">result.txt</span></span> file on Mac vs Windows, one being
UTF-8 encoded, the other ISO.
</p>

<p class="commentary">To get around this, all of the Inform tools have been given a command-line
setting:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">-locale LOCALE=ENCODING</span></span> where <span class="extract"><span class="extract-syntax">LOCALE</span></span> is one of <span class="extract"><span class="extract-syntax">shell</span></span> or <span class="extract"><span class="extract-syntax">console</span></span>, and
<span class="extract"><span class="extract-syntax">ENCODING</span></span> is one of <span class="extract"><span class="extract-syntax">platform</span></span>, <span class="extract"><span class="extract-syntax">utf-8</span></span> or <span class="extract"><span class="extract-syntax">iso-latin1</span></span>. (The <span class="extract"><span class="extract-syntax">platform</span></span>
encoding means "whatever is normal on the current platform".) Running with the
<span class="extract"><span class="extract-syntax">-verbose</span></span> option in <a href="../../../inweb/docs/index.html" class="internal">inweb</a> or <a href="index.html" class="internal">intest</a> will show the locales being used:
</p>

<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">intest/Tangled/intest</span><span class="ConsoleText-identifier-syntax"> -verbose</span>
<span class="ConsoleText-plain-syntax">    Installation path is /Users/gnelson/dev/intest</span>
<span class="ConsoleText-plain-syntax">    Locales are: shell = utf-8, console = utf-8</span>
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">intest/Tangled/intest</span><span class="ConsoleText-identifier-syntax"> -locale</span><span class="ConsoleText-plain-syntax"> console=iso-latin1</span><span class="ConsoleText-identifier-syntax"> -verbose</span>
<span class="ConsoleText-plain-syntax">    Installation path is /Users/gnelson/dev/intest</span>
<span class="ConsoleText-plain-syntax">    Locales are: shell = utf-8, console = iso-latin1</span>
</pre>
<p class="commentary">It's probably best not to change the <span class="extract"><span class="ConsoleText-extract-syntax">shell</span></span> locale, which affects the
encoding on (a) environment variables, (b) filenames when scanning directories,
and (c) command-line parameters, either in or out. Changing the <span class="extract"><span class="ConsoleText-extract-syntax">console</span></span>
locale, though, effectively makes standard output from an Inform tool conform
to the given locale. So:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">    step</span><span class="plain-syntax">: insomething/Tangled/insomething -locale console=utf-8 whatever &gt;result.txt</span>
</pre>
<p class="commentary">would produce the same result on MacOS as on Windows.
</p>

<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="M-iatcl.html">&#10094;</a></li><li class="progresscurrentchapter">M</li><li class="progresssection"><a href="M-iti.html">iti</a></li><li class="progresssection"><a href="M-iatcl.html">iatcl</a></li><li class="progresscurrent">wir</li><li class="progresssection"><a href="M-rc.html">rc</a></li><li class="progresschapter"><a href="P-htpw.html">P</a></li><li class="progresschapter"><a href="1-bsc.html">1</a></li><li class="progresschapter"><a href="2-rf.html">2</a></li><li class="progresschapter"><a href="3-ts.html">3</a></li><li class="progresschapter"><a href="4-tdc.html">4</a></li><li class="progressnext"><a href="M-rc.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>


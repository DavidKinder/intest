<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>How This Program Works</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
MathJax = {
	tex: {
		inlineMath: '$', '$'], ['\\(', '\\)'
	},
	svg: {
		fontCache: 'global'
	}
};
</script>
<script type="text/javascript" id="MathJax-script" async
	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/ConsoleText-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Intest.png" height=72">
</a></h1>
<ul><li><a href="index.html"><span class="selectedlink">intest</span></a></li>
</ul><h2>Repository</h2><ul>
<li><a href="https://github.com/ganelson/intest"><img src="../docs-assets/github.png" height=18> github</a></li>
</ul><h2>Related Projects</h2><ul>
<li><a href="../../../inweb/docs/index.html">inweb</a></li>
<li><a href="../../../inform/docs/index.html">inform</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'How This Program Works' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="index.html">intest</a></li><li><a href="index.html#P">Preliminaries</a></li><li><b>How This Program Works</b></li></ul></div>
<p class="purpose">An overview of how Intest works, with links to all of its important functions.</p>

<ul class="toc"><li><a href="P-htpw.html#SP1">&#167;1. Prerequisites</a></li><li><a href="P-htpw.html#SP2">&#167;2. Instructions and their blocks</a></li><li><a href="P-htpw.html#SP4">&#167;4. The Universe of Cases</a></li><li><a href="P-htpw.html#SP6">&#167;6. Instructions for action</a></li><li><a href="P-htpw.html#SP7">&#167;7. Performing actions</a></li><li><a href="P-htpw.html#SP8">&#167;8. Individual tests</a></li><li><a href="P-htpw.html#SP11">&#167;11. Intest used inside the Inform GUI app</a></li><li><a href="P-htpw.html#SP12">&#167;12. Adding to Intest</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. Prerequisites. </b>This page is to help readers to get their bearings in the source code for
Intest, which is a literate program or "web". Before diving in:
</p>

<ul class="items"><li>(a) It helps to have some experience of reading webs: see <a href="../../../inweb/docs/index.html" class="internal">inweb</a> for more.
</li><li>(b) Intest is written in C, in fact ANSI C99, but this is disguised by the
fact that it uses some extension syntaxes provided by the <a href="../../../inweb/docs/index.html" class="internal">inweb</a> literate
programming tool, making it a dialect of C called InC. See <a href="../../../inweb/docs/index.html" class="internal">inweb</a> for
full details, but essentially: it's C without predeclarations or header files,
and where functions have names like <span class="extract"><span class="extract-syntax">Tags::add_by_name</span></span> rather than just <span class="extract"><span class="extract-syntax">add_by_name</span></span>.
</li><li>(c) Intest makes use of a "module" of utility functions called <a href="../../../inweb/docs/foundation-module/index.html" class="internal">foundation</a>.
This is a web in its own right. There's no need to read it in full, but if
you haven't seen a Foundation-based program before, you may want to take a
quick look at <a href="../../../inweb/docs/foundation-module/P-abgtf.html" class="internal">A Brief Guide to Foundation (in foundation)</a>.
</li></ul>
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2. Instructions and their blocks. </b>Intest is a C program, so it begins at <a href="1-mn.html" class="internal">Main</a>. This works out where Intest
is installed, which project Intest is to test, and where the file specifying
the universe of tests is, but otherwise soaks up the command line arguments
into an array of "instructions". For example, if the user typed:
</p>

<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">intest/Tangled/intest</span><span class="ConsoleText-plain-syntax"> inform7</span><span class="ConsoleText-identifier-syntax"> -verbose</span><span class="ConsoleText-plain-syntax"> 1 2 Gelato</span>
</pre>
<p class="commentary">then the instructions array will be <span class="extract"><span class="ConsoleText-extract-syntax">-verbose</span></span>, <span class="extract"><span class="ConsoleText-extract-syntax">1</span></span>, <span class="extract"><span class="ConsoleText-extract-syntax">2</span></span>, <span class="extract"><span class="ConsoleText-extract-syntax">Gelato</span></span>.
</p>

<p class="commentary"><a href="1-mn.html" class="internal">Main</a> then calls out to <a href="2-th.html#SP4" class="internal">Historian::research</a> to look at the project's
test history log, and uses that to make substitutions: this is where <span class="extract"><span class="ConsoleText-extract-syntax">?3</span></span> might
be expanded into previous testing command number 3, or <span class="extract"><span class="ConsoleText-extract-syntax">6</span></span> might be expanded
into the test case name for currently-failing test number 6. In the case of
the example above, the instructions might now be <span class="extract"><span class="ConsoleText-extract-syntax">-verbose</span></span>, <span class="extract"><span class="ConsoleText-extract-syntax">Sackcloth</span></span>,
<span class="extract"><span class="ConsoleText-extract-syntax">Beatles</span></span>, <span class="extract"><span class="ConsoleText-extract-syntax">Gelato</span></span>.
</p>

<p class="commentary">Once <a href="2-th.html" class="internal">The Historian</a> is done, the instructions are passed to
<a href="1-cla.html#SP1" class="internal">Instructions::read</a>, which parses them much more fully (see below) and
returns an <a href="1-cla.html#SP1_3" class="internal">intest_instructions</a> object.
</p>

<p class="commentary"><a href="1-mn.html" class="internal">Main</a> then deals with a few incidental configuration switches &mdash; for
example, turning on or off coloured terminal text output &mdash; and then calls
<a href="2-gv.html#SP7" class="internal">Globals::start</a>. This creates the first two global variables available to
testing scripts: <span class="extract"><span class="ConsoleText-extract-syntax">$$platform</span></span>, which might be, say, <span class="extract"><span class="ConsoleText-extract-syntax">"Windows"</span></span>, and
<span class="extract"><span class="ConsoleText-extract-syntax">$$workspace</span></span>, the path to the temporary filing system space used by
Intest. Globals always have these double-dollar-signed names, and are
also created by USING blocks (see below): see the functions <a href="2-gv.html#SP4" class="internal">Globals::set</a>
and <a href="2-gv.html#SP3" class="internal">Globals::get</a>. Globals have only one data type &mdash; they all hold text;
but they are often just file system locations written out longhand. See
<a href="2-gv.html#SP5" class="internal">Globals::to_pathname</a> and <a href="2-gv.html#SP6" class="internal">Globals::to_filename</a>.
</p>

<p class="commentary">All is now prepared, and <a href="1-mn.html" class="internal">Main</a> simply hands over the <a href="1-cla.html#SP1_3" class="internal">intest_instructions</a>
to <a href="2-act.html#SP7" class="internal">Actions::perform</a>. Once that completes, <a href="2-th.html#SP6" class="internal">Historian::write_up</a> is
called to update the history log, and Intest returns 1 if errors occurred or
0 if they didn't, in traditional Unix fashion. Note that a return code of 0
doesn't mean the tests all passed, only that they were all carried out; you
get a return code of 1 if, for example, you ask for a nonexistent test, but
if you ask to test <span class="extract"><span class="ConsoleText-extract-syntax">Gelato</span></span> and it fails, the return code is 0.
</p>

<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3.  </b>Let's take a closer look at how <a href="1-cla.html#SP1" class="internal">Instructions::read</a> turns an array
like <span class="extract"><span class="ConsoleText-extract-syntax">-verbose</span></span>, <span class="extract"><span class="ConsoleText-extract-syntax">Sackcloth</span></span>, <span class="extract"><span class="ConsoleText-extract-syntax">Beatles</span></span>, <span class="extract"><span class="ConsoleText-extract-syntax">Gelato</span></span> into an <a href="1-cla.html#SP1_3" class="internal">intest_instructions</a>
object. It divides the array into contiguous runs called "blocks", each of which
is either:
</p>

<ul class="items"><li>(a) an OPTIONS block, like <span class="extract"><span class="ConsoleText-extract-syntax">-verbose</span></span>, <span class="extract"><span class="ConsoleText-extract-syntax">-colours</span></span> or <span class="extract"><span class="ConsoleText-extract-syntax">-threads=N</span></span>, handled by the
command-line-reading functions in the <a href="../../../inweb/docs/foundation-module/index.html" class="internal">foundation</a> library;
</li><li>(b) a DO block, introduced by <span class="extract"><span class="ConsoleText-extract-syntax">-do</span></span>, or by following directly on from the
conventional switches (a);
</li><li>(c) a USING block, introduced by <span class="extract"><span class="ConsoleText-extract-syntax">-using</span></span>.
</li></ul>
<p class="commentary">In the case of our example, there are just two blocks:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    OPTIONS    DO</span>
<span class="plain-syntax">    -verbose   Sackcloth Beatles Gelato</span>
</pre>
<p class="commentary">USING blocks are passed to <a href="2-rf.html#SP2" class="internal">RecipeFiles::read_using_instructions</a>. DO blocks
are passed to <a href="2-act.html#SP1" class="internal">Actions::read_do_instructions</a>, but only after the OPTIONS
block has been acted on, and after <a href="2-rf.html#SP1" class="internal">RecipeFiles::read</a> has parsed the recipe
file for the project being tested. This ordering is important, because it means
the universe of available test cases is fully known before a DO block is parsed.
For example, it will be known that <span class="extract"><span class="extract-syntax">Gelato</span></span> is the name of an available test case.
</p>

<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4. The Universe of Cases. </b><span class="extract"><span class="extract-syntax">-using</span></span> is seldom needed and could probably be dropped from Intest, but
USING blocks are essential and are needed on every run. This paradox is explained
by the fact that non-recipe commands in recipe files are in fact USING blocks.
Thus, if you type
</p>

<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">intest/Tangled/intest</span><span class="ConsoleText-plain-syntax"> example all</span>
</pre>
<p class="commentary">you've given only a DO block (<span class="extract"><span class="ConsoleText-extract-syntax">all</span></span>), but if <span class="extract"><span class="ConsoleText-extract-syntax">example/Tests/example.intest</span></span> begins:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    -cases 'example/Tests/Test Cases'</span>
</pre>
<p class="commentary">then it's as if you had typed
</p>

<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">intest/Tangled/intest</span><span class="ConsoleText-plain-syntax"> example</span><span class="ConsoleText-identifier-syntax"> -using -cases</span><span class="ConsoleText-plain-syntax"> 'example/Tests/Test Cases'</span><span class="ConsoleText-identifier-syntax"> -do</span><span class="ConsoleText-plain-syntax"> all</span>
</pre>
<p class="commentary">because lines like that in the recipe file are sent to <a href="2-rf.html#SP2" class="internal">RecipeFiles::read_using_instructions</a>
as USING blocks.
</p>

<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5.  </b>So what can USING blocks contain? A minimal amount of conditionality allows
for platform differences to be handled by <span class="extract"><span class="ConsoleText-extract-syntax">-if X</span></span>, ..., <span class="extract"><span class="ConsoleText-extract-syntax">-endif</span></span>: this works
by checking <span class="extract"><span class="ConsoleText-extract-syntax">X</span></span> against the <span class="extract"><span class="ConsoleText-extract-syntax">$$platform</span></span> global. <span class="extract"><span class="ConsoleText-extract-syntax">-set</span></span> calls <a href="2-gv.html#SP2" class="internal">Globals::create</a>
to make new globals, and <a href="2-gv.html#SP4" class="internal">Globals::set</a> to initialise them. But except for a
few side-shows like these, the business is to discover the universe of test cases.
</p>

<p class="commentary">That universe is stored as a list of <a href="2-rf.html#SP2_8_1" class="internal">test_source</a> objects, each of
which holds a list of <a href="2-rf.html#SP8" class="internal">test_case</a> objects coming from them. (There is one
<a href="2-rf.html#SP8" class="internal">test_case</a> for each individually testable case.) Sources might be single
named files, files containing multiple test cases embedded in some elaborate
way (as with Inform 7 extensions), or directories holding batches of tests.
</p>

<p class="commentary">The work is done by <a href="2-rf.html#SP5" class="internal">RecipeFiles::scan_directory_for_cases</a> and
<a href="2-rf.html#SP6" class="internal">RecipeFiles::scan_file_for_cases</a>; the former calls the latter on its
contents, but the latter is also called directly when the USING command
names a single file rather than a directory.
</p>

<p class="commentary"><a href="2-rf.html#SP6" class="internal">RecipeFiles::scan_file_for_cases</a> makes one or more cases out of a single
file. In simple cases, the file is the test case, and all we need do is hand
down to <a href="2-rf.html#SP9" class="internal">RecipeFiles::new_case</a>. In more complicated cases, the file is in
some elaborate format inside of which test cases are embedded, and we have
to call <a href="2-te.html" class="internal">The Extractor</a> to extricate them: either way, though, the end
result is that <a href="2-rf.html#SP9" class="internal">RecipeFiles::new_case</a> makes each <a href="2-rf.html#SP8" class="internal">test_case</a> object.
</p>

<p class="commentary">What we get for our trouble is a function, <a href="2-rf.html#SP3" class="internal">RecipeFiles::find_case</a>, which
returns the <a href="2-rf.html#SP8" class="internal">test_case</a> for a test name like <span class="extract"><span class="ConsoleText-extract-syntax">Gelato</span></span>, or returns <span class="extract"><span class="ConsoleText-extract-syntax">NULL</span></span>
if no test has that name.
</p>

<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6. Instructions for action. </b>As noted above, DO blocks are parsed by <a href="2-act.html#SP1" class="internal">Actions::read_do_instructions</a>.
They typically tell Intest to perform an action on one or more test cases,
perhaps named individually, perhaps collectively. There are around 20 actions,
but the default is <span class="extract"><span class="ConsoleText-extract-syntax">-test</span></span>, so that our example DO block of <span class="extract"><span class="ConsoleText-extract-syntax">Sackcloth Beatles Gelato</span></span>
is actually parsed as if it were <span class="extract"><span class="ConsoleText-extract-syntax">-test Sackcloth Beatles Gelato</span></span>.
</p>

<p class="commentary">The DO block is converted into a list of <a href="2-act.html#SP2" class="internal">action_item</a> objects, each made
by <a href="2-act.html#SP3" class="internal">Actions::create</a>. For <span class="extract"><span class="ConsoleText-extract-syntax">-test Sackcloth Beatles Gelato</span></span>, there would be
three, just as if we had typed <span class="extract"><span class="ConsoleText-extract-syntax">-test Sackcloth -test Beatles -test Gelato</span></span>.
On the other hand, <span class="extract"><span class="ConsoleText-extract-syntax">-test all</span></span> produces only one <a href="2-act.html#SP2" class="internal">action_item</a>. This is
because an action item is an instruction to act on all test cases which match
a <a href="2-act.html#SP4" class="internal">case_specifier</a>, and while that can be an explicit name like <span class="extract"><span class="ConsoleText-extract-syntax">Sackcloth</span></span>,
it can also be a "wildcard" like <span class="extract"><span class="ConsoleText-extract-syntax">all</span></span> or <span class="extract"><span class="ConsoleText-extract-syntax">extensions</span></span>, or even everything in
a named group, or everything whose name matches a regular expression.
See <a href="2-act.html#SP5" class="internal">Actions::parse_specifier</a> for the syntax.
</p>

<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7. Performing actions. </b>At this point in the story, then, the instructions have been fully read, and
the recipe file has been read too. The universe of cases is known, and it's
known what the user wants us to do with which subsets of those cases. <a href="1-mn.html" class="internal">Main</a>
has just called <a href="2-act.html#SP7" class="internal">Actions::perform</a>, and it's time for something to happen.
</p>

<p class="commentary"><a href="2-act.html#SP7" class="internal">Actions::perform</a> begins by calling <a href="3-th.html#SP4" class="internal">Hasher::read_hashes</a> to discover
any MD5 hashes of known-to-be-correct test cases, and finishes by calling
<a href="3-th.html#SP5" class="internal">Hasher::write_hashes</a> to update these. Otherwise, it works by acting on
each <a href="2-act.html#SP2" class="internal">action_item</a> in turn. Some actions, such as <span class="extract"><span class="ConsoleText-extract-syntax">-find</span></span> or <span class="extract"><span class="ConsoleText-extract-syntax">-catalogue</span></span>,
are taken care of immediately, but most, such as <span class="extract"><span class="ConsoleText-extract-syntax">-test</span></span> or <span class="extract"><span class="ConsoleText-extract-syntax">-bless</span></span>, are
"scheduled" by calling <a href="3-ts.html#SP8" class="internal">Scheduler::schedule</a>. This does not act immediately
but, as the name suggests, schedules the tests for later: that later comes
at the end of <a href="2-act.html#SP7" class="internal">Actions::perform</a>, when it calls <a href="3-ts.html#SP9" class="internal">Scheduler::test</a>.
</p>

<p class="commentary">The reason for doing that is that <a href="3-ts.html" class="internal">The Scheduler</a> must allocate tests to
individual threads. The expectation is that if the host computer has \(N\)
processor cores, then there will be \(N\) simultaneous testing threads running,
and it's <a href="3-ts.html" class="internal">The Scheduler</a> which spreads the tests out, rather as if it were
dealing out a pack of cards to \(N\) players sitting around a table.
</p>

<p class="commentary">Each thread runs from <a href="3-ts.html#SP10" class="internal">Scheduler::perform_work</a>, a function which runs
through its tests &mdash; its hand of cards, as it were &mdash; and then marks itself
idle so that <a href="3-ts.html#SP10" class="internal">Scheduler::perform_work</a>, which is asleep on the main thread
but wakes once per second to check on the workers, can then close it.
Once all threads have finished, and Intest is back to being a single-threaded
program, <a href="3-ts.html#SP10" class="internal">Scheduler::perform_work</a> summarises the results.
</p>

<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8. Individual tests. </b>What the workers do is to call <a href="4-tt.html#SP1" class="internal">Tester::test</a> on each <a href="3-ts.html#SP8" class="internal">test</a> it is given.
A <a href="3-ts.html#SP8" class="internal">test</a> object is essentially an action code, plus a <a href="2-rf.html#SP8" class="internal">test_case</a>, plus
a work area in the file system &mdash; each worker thread has its own work area,
since otherwise interference between them would create havoc; but successive
tests run by the same worker use the same work area, which is cleaned after
each use by <a href="4-tt.html#SP3" class="internal">Tester::purge_work_area</a>.
</p>

<p class="commentary">The bulk of <a href="4-tt.html#SP1" class="internal">Tester::test</a>, though, is an interpreter for the "recipe"
program &mdash; that is, the Delia program assigned to the test case in question,
which has been precompiled into a quick-to-interpret form by <a href="4-tdc.html" class="internal">The Delia Compiler</a>,
something which was done back when the recipe file was read in.
</p>

<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9.  </b>The most complex algorithm in Intest is probably the one performing token
expansion, at <a href="4-tt.html#SP5" class="internal">Tester::expand</a>. This expands a token like <span class="extract"><span class="ConsoleText-extract-syntax">$WORK/Example.inform</span></span>
by substituting in the current value of the variable <span class="extract"><span class="ConsoleText-extract-syntax">$WORK</span></span> &mdash; note that these
are single-dollar, i.e. local to the current recipe, variables, as distinct from
the double-dollar, global, ones. That expansion process isn't so simple because
if <span class="extract"><span class="ConsoleText-extract-syntax">$WORK</span></span> expands to a filename with spaces in, then we may need to end up with
something which still ends up as a single shell command token &mdash; see
<a href="4-tt.html#SP6" class="internal">Tester::quote_expand</a> for how this is done.
</p>

<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10.  </b>When tests fail, it is usually because some output text doesn't match the
"blessed" text which had been expected &mdash; only usually, because Delia recipes can
fail tests for quite a number of reasons. Still, this is the commonest case,
and then <a href="3-td.html" class="internal">The Differ</a> performs a Unix-style <span class="extract"><span class="ConsoleText-extract-syntax">diff</span></span> (i.e., summary of
differences) which can be reported back at the command line. <a href="3-td.html" class="internal">The Differ</a>
is a somewhat crude mechanism, probably the weakest part of Intest at present:
though it presents its output nicely, which is valuable, it has terrible
running time on really enormous outputs; in those cases, the Unix <span class="extract"><span class="ConsoleText-extract-syntax">diff</span></span> tool
would do rather better. More work could probably be done here.
</p>

<p class="commentary firstcommentary"><a id="SP11" class="paragraph-anchor"></a><b>&#167;11. Intest used inside the Inform GUI app. </b>On MacOS, the Inform application includes a copy of the <span class="extract"><span class="ConsoleText-extract-syntax">intest</span></span> binary, and
uses it to perform automated testing of the test cases in an extension, for
extension projects. This requires us to generate output in a different format,
since we're reporting back to the app rather than to the user at the command
line. See <a href="3-tr.html" class="internal">The Reporter</a> for how this is done.
</p>

<p class="commentary firstcommentary"><a id="SP12" class="paragraph-anchor"></a><b>&#167;12. Adding to Intest. </b>Here's some miscellaneous advice for those who would like to add to Intest:
</p>

<p class="commentary">1. If what you want is to have a form of test which runs differently, see
first if this can be accomplished with a Delia recipe combined, perhaps, with
use of <span class="extract"><span class="ConsoleText-extract-syntax">-set</span></span> to create new global variables. The combination is quite potent.
</p>

<p class="commentary">2. But if that isn't good enough, try to do it with a minimal extension to the
Delia language. You'll need to make matching changes to <a href="4-tdc.html#SP6" class="internal">Delia::compile</a>
and <a href="4-tt.html#SP1" class="internal">Tester::test</a>, and to add documentation to <a href="M-wir.html" class="internal">Writing Intest Recipes</a>.
</p>

<p class="commentary">3. If that still isn't good enough, and what you really need is a different
way to process existing recipes, see if a new action &mdash; such as <span class="extract"><span class="ConsoleText-extract-syntax">-test</span></span>,
<span class="extract"><span class="ConsoleText-extract-syntax">-bless</span></span>, <span class="extract"><span class="ConsoleText-extract-syntax">-rebless</span></span> and so on &mdash; would meet your needs. If so, add this to
<a href="2-act.html#SP1" class="internal">Actions::read_do_instructions</a> and <a href="2-act.html#SP7" class="internal">Actions::perform</a>, and document it
at <a href="M-iatcl.html" class="internal">Intest at the Command Line</a>.
</p>

<p class="commentary">4. Only if that really can't cope should you add a new OPTION block option,
but if so, see <a href="1-cla.html#SP1" class="internal">Instructions::read</a> and <a href="1-cla.html#SP4" class="internal">Instructions::respond</a>, and
again, document at <a href="M-iatcl.html" class="internal">Intest at the Command Line</a>.
</p>

<p class="commentary">5. If what you want is to expand the universe of test cases in a new way &mdash;
say, to pull them down from some Internet-based repository rather than read
them from local files &mdash; create a new category of <a href="2-rf.html#SP2_8_1" class="internal">test_source</a>, and
add this to <a href="2-rf.html#SP2" class="internal">RecipeFiles::read_using_instructions</a>.
</p>

<p class="commentary">6. As with any program built on Foundation, if you are creating a new class of
object, don't forget to declare it in <a href="1-bsc.html" class="internal">Basics</a>.
</p>

<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="M-rc.html">&#10094;</a></li><li class="progresschapter"><a href="M-iti.html">M</a></li><li class="progresscurrentchapter">P</li><li class="progresscurrent">htpw</li><li class="progresschapter"><a href="1-bsc.html">1</a></li><li class="progresschapter"><a href="2-rf.html">2</a></li><li class="progresschapter"><a href="3-ts.html">3</a></li><li class="progresschapter"><a href="4-tdc.html">4</a></li><li class="progressnext"><a href="1-bsc.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>


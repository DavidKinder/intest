<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Booklet Title</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Sources</a></h1>
<ul>
<li><a href="../intest/index.html">intest</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of 'P/iti' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Source</a></li><li><a href="index.html">intest 2.0</a></li><li><a href="index.html#P">Preliminaries</a></li><li><b>Introduction to Intest</b></li></ul><p class="purpose">What Intest is, and a simple example of what it can do.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Introduction</a></li><li><a href="#SP2">&#167;2. Recipes</a></li><li><a href="#SP3">&#167;3. Installation</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Introduction. </b>Intest is a command line tool for testing command line tools. It was
originally written for testing the Inform 7 compiler, and has been used
heavily and continuously for that purpose since 2004. But it can in fact
test any command-line tool with broadly textual output. While it's a natural
sidekick for the literate programming tool Inweb, it can work just as easily
on programs written by other means.
</p>

<p class="inwebparagraph">Intest is at its best when running a batch of tests, each of which can follow
a complex multi-stage sequence if necessary. Tests are automatically spread
across multiple threads so that the batch can be finished as soon as
possible, and results are tidily collated. Intest has a command-line syntax
which makes a sort of conversation possible: start by testing a batch, then
retest those which fail, fixing them one by one, and so on. For example,
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ intest/Tangled/intest -from myproject all</span>
        <span class="plain">myproject -&gt; cases: [1] [2] [3] [4] </span>
        <span class="plain">Discrepancy at line 7:</span>
        <span class="plain">    Planet is: Joopiter</span>
        <span class="plain">[5] planets produced incorrect output</span>
        <span class="plain">[6] [7] [8] [9]</span>
        <span class="plain">  8 tests succeeded but 1 failed (time taken 0:02, 9 simultaneous threads)</span>
        <span class="plain">Failed: 1=planets</span>
</pre>

<p class="inwebparagraph">Suppose we go fix that bug, and then retest:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ intest/Tangled/intest -from myproject 1</span>
        <span class="plain">Expanded to: ?322. planets</span>
        <span class="plain">[1] planets passed</span>
</pre>

<p class="inwebparagraph">Note that <code class="display"><span class="extract">1</span></code> was understood by Intest here as referring to the test case
<code class="display"><span class="extract">planets</span></code> which failed earlier. Intest is recording a history of recent
tests run, too: this one was test run <code class="display"><span class="extract">?322</span></code>. We could have listed those by
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ intest/Tangled/intest -from myproject ?</span>
</pre>

<p class="inwebparagraph">and recalled any of them by number:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ intest/Tangled/intest -from myproject ?315</span>
        <span class="plain">Repeating: ?315. rockets moons</span>
        <span class="plain">[1] rockets passed</span>
        <span class="plain">[2] moons passed</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. Recipes. </b>Intest assumes that each project will have its own universe of tests.
These can take many forms, but the commonest are to give valid input and
check to see some expected output, or else to give invalid input and check
to see that some expected error message is produced.
</p>

<p class="inwebparagraph">Each individual test is performed by following a "recipe". Recipes are simple
mini-language called Delia, which sits on top of the host operating system's
command-line shell. For example, here is Delia code for testing what ought to
be a valid input to a tool called
<code class="display"><span class="extract">zap</span></code> inside the <code class="display"><span class="extract">myproject</span></code> folder:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">set: $A = $PATH/_actual/$CASE.txt</span>
        <span class="plain">set: $I = $PATH/_ideal/$CASE.txt</span>
        <span class="plain">step: myproject/zap $PATH/$CASE.txt &gt;$A 2&gt;&amp;1</span>
        <span class="plain">or: 'failed zap' $A</span>
        <span class="plain">show: $A</span>
        <span class="plain">match text: $A $I</span>
        <span class="plain">or: 'produced the wrong output'</span>
        <span class="plain">pass: 'passed'</span>
</pre>

<p class="inwebparagraph">This looks more forbidding than it is. Variables start with a dollar, as in
most Unix mini-languages: they usually hold filenames. <code class="display"><span class="extract">$CASE</span></code> is the name
of the current test case: perhaps "planets". <code class="display"><span class="extract">$PATH</span></code> is the pathname to its
folder, which might be, for example, "myproject/tests". What happens is:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">set: $A = $PATH/_actual/$CASE.txt</span>
        <span class="plain">set: $I = $PATH/_ideal/$CASE.txt</span>
</pre>

<p class="inwebparagraph">This sets two filenames &mdash; it doesn't create these files, simply creates
two names. <code class="display"><span class="extract">$A</span></code> is going to be the actual output printed out by the program
being tested, while <code class="display"><span class="extract">$I</span></code> is the ideal output, that is, what it should have
printed. Next:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">step: myproject/zap $PATH/$CASE.txt &gt;$A 2&gt;&amp;1</span>
</pre>

<p class="inwebparagraph">A "step" is a stage in a test which involves issuing a shell command, and
which passes or fails according to the exit code from that command, exactly
as it would in a tool like <code class="display"><span class="extract">make</span></code>. We're going to assume <code class="display"><span class="extract">zap</span></code> is a simple
sort of program, which takes one command-line argument &mdash; a filename &mdash;
does something with that file, and prints out something interesting about it.
</p>

<p class="inwebparagraph">Intest substitutes in values for the variables, so the actual shell command
might be:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">myproject/zap myproject/tests/planets.txt &gt;myproject/tests/_actual/planets.txt 2&gt;&amp;1</span>
</pre>

<p class="inwebparagraph">which uses bash shell notation to redirect both printed output, and error
messages, to the <code class="display"><span class="extract">$A</span></code> file. That, as promised, is the "actual output".
</p>

<p class="inwebparagraph">The next line in the recipe is then:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">or: 'failed zap' $A</span>
</pre>

<p class="inwebparagraph">This tells Intest to halt the test if the shell command failed (i.e., if
<code class="display"><span class="extract">zap</span></code> exited with a non-zero exit value). Intest uses the brief epitaph
"failed zap" when summarising what happened, and prints out <code class="display"><span class="extract">$A</span></code>,
because presumably it ends with some error messages which the tester will
want to see.
</p>

<p class="inwebparagraph">So the recipe is only continued if, in fact, <code class="display"><span class="extract">zap</span></code> did not produce error
messages. The next line is not quite what it seems:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">show: $A</span>
</pre>

<p class="inwebparagraph">This tells Intest that if the tester ran the test specifying <code class="display"><span class="extract">-show</span></code> on
the command line then <code class="display"><span class="extract">$A</span></code> is the right file to print out. If the tester
didn't say <code class="display"><span class="extract">-show</span></code>, we print nothing here, and continue. The next steps
in the recipe are more consequential:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">match text: $A $I</span>
        <span class="plain">or: 'produced the wrong output'</span>
</pre>

<p class="inwebparagraph">This does what it looks as if it should, but it has hidden powers. If the
tester hasn't yet created a file of ideal output, then there's nothing to
compare against. In that case Intest doesn't fail the stage, but it does
mark it in the summary:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ intest/Tangled/intest -from myproject planets</span>
        <span class="plain">-1- planets passed</span>
</pre>

<p class="inwebparagraph">The notation <code class="display"><span class="extract">-1-</span></code>, rather than the more usual <code class="display"><span class="extract">[1]</span></code>, conveys that the
test was incompletely passed in this way. This is easy to fix. If we're
happy with the actual output, we "bless" it:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ intest/Tangled/intest -from myproject -bless planets</span>
        <span class="plain">[1] planets passed</span>
</pre>

<p class="inwebparagraph">With <code class="display"><span class="extract">-bless</span></code> specified, when the recipe hits:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">match text: $A $I</span>
</pre>

<p class="inwebparagraph">Intest sets the ideal output to the actual output: the two then necessarily
match, so the stage passes. (It's also possible to <code class="display"><span class="extract">-curse</span></code> a test, which deletes its ideal
output, or to <code class="display"><span class="extract">-rebless</span></code> it, which replaces the current ideal output
in favour of the current actual output &mdash; in effect, it performs a curse
immediately followed by a blessing.)
</p>

<p class="inwebparagraph">Either way, if the recipe is still running at this point, all is good:
<code class="display"><span class="extract">zap</span></code> produced no error messages, and we have output which is not known
to be incorrect. So we conclude with a triumphant:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">pass: 'passed'</span>
</pre>

<p class="inwebparagraph">Recipes can be substantially longer and more elaborate, running through
a sequence of tools, or running the same test material in a sequence of
different ways. The recipes used by the main Inform compiler occupy about
400 lines like the above, though always with the same basic manoeuvres
over and over again. A typical test batch for that project involves
over 2000 cases. Intest is a simple tool at heart, but it was written
with an eye to speed and flexibility.
</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Installation. </b>Intest is a "literate program", and to compile it from source you should
first obtain the literate programming tool Inweb. (Both are available from
Github.)
</p>

<p class="inwebparagraph">To begin, place the distribution directories <code class="display"><span class="extract">intest</span></code> and <code class="display"><span class="extract">inweb</span></code> in the
same parent directory, and then change working directory to that. Thus, you
should reach:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ ls</span>
        <span class="plain">intest   inweb</span>
</pre>

<p class="inwebparagraph">(and perhaps lots of other stuff too). Be sure to make Inweb first: see
its own documentation for that. Then:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ inweb/Tangled/inweb intest -makefile intest/intest.mk</span>
</pre>

<p class="inwebparagraph">This makes the makefile we will use. It will automatically be configured
suitably for the operating system we're using: the MacOS version of Inweb
will make us a MacOS version of this makefile, and so on. Now we can make:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ make -f intest/intest.mk</span>
</pre>

<p class="inwebparagraph">All being well, you now have a working Intest. The executable is in
<code class="display"><span class="extract">intest/Tangled/intest</span></code>, so:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ intest/Tangled/intest -help</span>
</pre>

<p class="inwebparagraph">should verify that it's in working order. A more interesting test is:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ intest/Tangled/intest -from inweb all</span>
</pre>

<p class="inwebparagraph">which runs the Inweb test suite (a very modest one, as it happens).
</p>

<p class="inwebparagraph">Users of, for example, the <code class="display"><span class="extract">bash</span></code> shell may want to
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ alias intest='intest/Tangled/intest'</span>
</pre>

<p class="inwebparagraph">to save a little typing, but in this documentation we always spell it out.
</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>When it runs, Intest needs to know where it is installed in the file
system. There is no completely foolproof, cross-platform way to know this
(on some Unixes, a program cannot determine its own location), so Intest
decides by the following set of rules:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(a) If the user, at the command line, specified <code class="display"><span class="extract">-at P</span></code>, for some path
<code class="display"><span class="extract">P</span></code>, then we use that.
</li><li>(b) Otherwise, if the host operating system can indeed tell us where the
executable is, we use that. This is currently implemented only on MacOS,
Windows and Linux.
</li><li>(c) Otherwise, if the environment variable <code class="display"><span class="extract">$INTEST_PATH</span></code> exists and is
non-empty, we use that.
</li><li>(d) And if all else fails, we assume that the location is <code class="display"><span class="extract">intest</span></code>, with
respect to the current working directory.
</li></ul>
<p class="inwebparagraph">If you're not sure what Intest has decided and suspect it may be wrong,
running Intest with the <code class="display"><span class="extract">-verbose</span></code> switch will cause it to print its belief
about its location as it starts up.
</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>Intest returns an exit code of 0 if successful, or else it throws errors
to <code class="display"><span class="extract">stderr</span></code> and returns 1 if unsuccessful. Successful means that it did what it
was asked to do: if it was asked to conduct a test and the test failed,
Intest was still successful (the test was after all conducted), so it
returns 0.
</p>

<hr class="tocbar">
<ul class="toc"><li><i>(This section begins Preliminaries.)</i></li><li><a href="P-iatcl.html">Continue with 'Intest at the Command Line'</a></li></ul><hr class="tocbar">
<!--End of weave-->
		</main>
	</body>
</html>

